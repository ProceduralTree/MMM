#+title: Multiscale Finite Volume Method
#+author: Karl Louis Gl√§nzer / Jonathan Ulmer
#+startup: latexpreview
#+startup: beamer
#+latex_compiler: lualatex
#+latex_class: beamer
#+LaTeX_CLASS_options: [presentation,small]
#+property: header-args:python :session :tangle fv.py :comments org :exports both :eval never-export
#+OPTIONS: H:2 toc:t num:t
#+BEAMER_THEME: Madrid
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+BEAMER_FRAME_OPTIONS: allowframebreaks
#+LATEX_HEADER: \setkeys{Gin}{width=0.6\textwidth}


* Preamble :noexport:
#+begin_src python :tangle src/fvsolver.py :noweb no-export :exports none
from typing import Callable
import numpy as np
from scipy.sparse import spdiags
from scipy.sparse.linalg import spsolve
from numpy.typing import NDArray
#+end_src

#+RESULTS:
: None


#+begin_src python  :exports none
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
#+end_src

#+RESULTS:
: None

#+begin_src python :tangle src/diffusion.py
import numpy as np
#+end_src


* Standard Diffusion equation
** Numerical Problem :noexport:
#+begin_abstract
in our work, we solve the diffusion equation \eqref{eq:diffusion} with zero Dirichlet boundary and constant soure term \(f(x) = 1\). In order to investigate the effects of the multiscale method on the solution, we introduce a varied sample of diffusivity terms
\begin{align}
\label{eq:diffusion}
\nabla \cdot (D(x) \nabla c) &= f(x) & \text{in}& \, \Omega \\
c(x) &= 0 &  \text{on}& \, \partial \Omega
\end{align}
Our work provides a way to approximate a solution \(c\) to the PDE \eqref{eq:diffusion} with the Finite Volume method, and a multiscale adaptation.
#+end_abstract
** Numerical Problem
*** Diffusion Equation
- We solve the diffusion equation \eqref{eq:diffusion}
\begin{align}
\label{eq:diffusion}
\nabla \cdot (D(x) \nabla c) &= f(x) & \text{in}& \, \Omega \\
\label{eq:dirichlet}
c(x) &= 0 &  \text{on}& \, \partial \Omega
\end{align}
- with Dirichlet boundary \eqref{eq:dirichlet}
- We use constant source \(f(x) = 1 , x \in  \Omega \)
- We use a Finite Volume solver
** Derivation of the 1D Finite Volume Method :noexport:
The Finite Volume method considers the differential equation in Integral form over disjunct (\(Q_i \cap Q_j = \emptyset , i\neq  j\)) reference cells \(Q_{i}\), \(\bigcup_{i=1}^N  Q_{i} = \Omega \) and calculates the integral over them, with an integral over the reference cell boundaries using Stokes integration.


\begin{align}
\label{eq:fv-integral}
\int_{Q_i} \nabla \cdot (D(x) \nabla c )  &= \int_{Q_i} f(x) \, \mathrm{d}x  & i&=1, \dots  , N\\
\int_{\partial Q_i} D(x) \nabla c \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N
\end{align}


The Finite Volume Method then considers the solution piecewise constant on \(Q\). This creates discontinuities on the cell boundaries, where the values are not uniquely defined.
The Finite Volume method therefore introduces a numerical flux in the Ansatz and solves the integral over the flux instead.
Since the assumed solution is constant we approximate the source term \(f(\vec{x})\)  with its value on the cell center \(x_i\) of \(Q_i\) and calculate the integrals directly.

\begin{align}
\int_{\partial Q_i} g(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N\\
\label{eq:fv-discrete}
 \int_{\partial Q_i} g(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \,&=   |Q_i| f(x_i)  & i&=1, \dots  , N
\end{align}
** Derivation of the 1D Finite Volume Method
*** Discretization
- Divide \(\Omega \) into a uniform grid \(\{Q_i\}\)
  - cells \(Q_i\) are disjunct
  - \(Q_i \cap Q_j = \emptyset , i\neq  j\)
  - we assume constant solution \(c_i\) on \(Q_i\)
  - we assume constant source \(f(x) = f_i ,\, x \in Q_i\)
*** Integral Form
- since the Diffusion EQ.\eqref{eq:diffusion} holds on \(\Omega \), it holds for any integral.
- \(\implies \) \eqref{eq:diffusion} holds for the integral over \(Q_i\)
\begin{equation}
\begin{aligned}
\nabla \cdot (D(x) \nabla c) &= f(x) & \text{in}& \, \Omega \\
\label{eq:cell-integral}
\int_{Q_i} \nabla \cdot (D(x) \nabla c )  &= \int_{Q_i} f(x) \, \mathrm{d}x  & i&=1, \dots  , N
\end{aligned}
\end{equation}
- We use the constant source to evaluate the right hand side
\begin{align}
\label{eq:2}
\int_{\partial Q_i} D(x) \nabla c \cdot \vec{n} \, \mathrm{d}S \, &=  |Q_i| f_i  & i&=1, \dots  , N
\end{align}
*** Numerical Flux
- constant solution
- \(c\) is discontinuous on \(\partial Q\)
- \(\nabla c\) is not defined on the cell boundary
- we replace \(D(x) \nabla c\) with numerical flux \(\vec{g}\)
- \(\vec{g}\) describes flux of the solution between neighbouring cells
\begin{align}
\int_{\partial Q_i} D(x) \nabla c \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N\\
\int_{\partial Q_i} \vec{g}(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N
\end{align}
** Numerical flux approximation
*** 1D Flux
We employ the  flux approximation introduced in the MMM Lecture. Since we only investigated diffusion terms with an analytical representation, we are able to calculate this value directly.
\begin{align}
\label{eq:flux-1d}
g(c^+ , c^-) = - D(x^{\frac{1}{2} +}) \frac{c^+ - c^-}{h}
\end{align}
Furthermore, we introduce transmissitivities \(T_{\pm }\) between both cells.
\begin{align*}
g(c^+ , c^-) &= T_{\pm } * \left( c^+ - c^- \right) \\
T_{\pm } &= - D(x^{\frac{1}{2}+}) \frac{1}{h}
\end{align*}
*** 2D Flux
We define the flux term \(\vec{g} := (g_x , g_y)^T\) in 2 Dimensions very similar to those in one dimension.
\begin{align}
\label{eq:flux-2d}
g_{x}(c_{i+1,j} , c_{ij}) &= - \Delta_y D(x_{i+ \frac{1}{2},j }) \frac{c_{i+1,j} - c_{ij}}{\Delta_x}\\
g_y(c_{i,j+1} , c_{ij}) &= - \Delta_x D(x_{i,j+ \frac{1}{2}}) \frac{c_{i,j+1} - c_{ij}}{\Delta_y}
\end{align}
and in the same manner we introduce 2D transmissions \(T^x_{i+1j} , T^y_{ij+1}\)
\begin{align*}
g_x(c_{i+1j} , c_{ij}) &=   T^x_{i+1j} \left( c_{i+1j} - c_{ij}  \right)\\
g_y(c_{ij+1} , c_{ij}) &=   T^y_{ij+1} \left( c_{i+1j} - c_{ij}  \right)
\end{align*}
** Linearization
*** Reference Cell :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+name: fig:reference-cell
#+attr_latex: :width 0.9\textwidth
[[file:images/reference-cell.svg]]
*** Explanation :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:
- only 4 normals in 2D (2 in 1D)
- integral simplifies
\begin{align*}
 \int_{\partial Q_i} \vec{g}(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \,&=   |Q_i| f_i\\
\sum_{ n \in \partial Q}   \vec{g}(c_{ij+\vec{n}} , c_{ij}) \cdot \vec{n}  &=   |Q_i|  f_i
\end{align*}
*** Explanation :noexport:
We implemented our finite Volume solver on a rectangular grid. therefore the normals on the boundaries are constant, and the flux integral (\ref{eq:fv-discrete}) simplifies to a sum
\begin{align*}
 \int_{\partial Q_i} \vec{g}(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \,&=   |Q_i| f(x_i)  & i&=1, \dots  , N \\
\sum_{ n \in \partial Q}   \vec{g}(c_{i+j+1} , c_{i+j}) \cdot \vec{n}  &=   |Q_i|  \overline{f}(x_{i})
\end{align*}

*** 1D Flux :noexport:
- In one dimension there are only two outward normals \(n \in \{-1,1\}\),
- we use the 1D flux \eqref{eq:flux-1d}

*** TODO 2D replace with image :noexport:

- In two dimensions there are four outward cell normals
\begin{align*}
n_{\mathrm{north}}  &=
\begin{pmatrix}
0 \\ 1
\end{pmatrix}
&
n_{\mathrm{south}}  &=
\begin{pmatrix}
0 \\ -1
\end{pmatrix}
\\
n_{\mathrm{east}}  &=
\begin{pmatrix}
1 \\ 0
\end{pmatrix}
&
n_{\mathrm{west}}  &=
\begin{pmatrix}
-1 \\ 0
\end{pmatrix}
\end{align*}
- we use the 2D flux \eqref{eq:flux-2d}

** Multiscale
*** Image :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:

#+attr_latex: :width 0.9\textwidth
[[file:images/microscale-reference.svg]]
*** Explanation :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:
- Adds  microscale simulation
  - one dimensional
  - for each normal
  - \(n\) subgrid cells
- Calculates Transmissions \(T_{ij}\)
  - with microscale solution \(\phi \)
\begin{align*}
T_{\pm } &= -\int_{Q} D(x) (\phi'_{\pm} (x))^2\, \mathrm{d}x
\end{align*}
* Example diffusion terms

** Diffusion 
We investigate of single and multiscale solvers with different Diffusion functions, that we introduce in the following sections

** 1D

Since the Aim of multiscale Finite Volume, is to improve the results for highly fluctuating diffusivities, we test with the following oscillating function
*** Code
#+begin_src python :tangle src/diffusion.py :eval never
def oscillation(x, eps = 0.1):
    return 1 / (2+1.9 * np.cos(2 * np.pi* x / eps))
#+end_src

*** Diffusivity
#+name: 1D Diffusion
#+begin_src python  :session :results output file graphics  :file images/D.svg :exports results
import numpy as np
import matplotlib.pyplot as plt
import src.diffusion as D
reload(D)
x = np.linspace(0,1 ,10)
plt.plot(x , D.oscillation(x))
x_highres = np.linspace(0,1 , 100000)
plt.plot(x_highres , D.oscillation(x_highres))
plt.legend([r"$D$ Sampled on a course grid" , r"$D$"] , loc="upper right")
plt.title("1D Diffusion Coefficient")
#+end_src

#+caption: Oscillating Diffusivity for 1D finite volume method
#+RESULTS: 1D Diffusion
[[file:images/D.svg]]




** 2D Oscillation
*** Code
#+begin_src python :tangle src/diffusion.py
def osc2D_point(x,y , eps = 0.25):
    return oscillation(x, eps=eps) * oscillation(y, eps=eps)
def osc2D_line(x,y , eps = 0.25):
    return np.maximum(oscillation(x, eps=eps) , oscillation(y, eps=eps))

#+end_src

#+RESULTS:
: None

*** Diffusion
#+name: 2D Ocillation
#+begin_src python :results graphics file output :file images/oscillation-2d.svg :exports results
import src.diffusion as D
reload(D)


N = 1000
M = 1000
x = np.linspace(0.,1., N)
y= np.linspace(0.,1., M)
grid = np.meshgrid(x,y)
diffusion_b = D.osc2D_point(grid[0] , grid[1])
diffusion_b = diffusion_b.reshape((N,M))
diffusion_c = D.osc2D_line(grid[0] , grid[1])
diffusion_c = diffusion_c.reshape((N,M))

fig,axis= plt.subplots(1,2 , figsize=(10,4))
im1 = axis[0].imshow(diffusion_b , cmap="magma" , extent=[0,1,0,1])
axis[0].set_title(r"0D Obstacles")
im2 = axis[1].imshow(diffusion_c , cmap="magma" , extent=[0,1,0,1])
axis[1].set_title(r"1D Obstacles")

#fig.colorbar()
fig.suptitle(r"Oscillating Diffusion")
fig.colorbar(im1 ,ax=axis , fraction=0.025)
#+end_src

#+RESULTS: 2D Ocillation
[[file:images/oscillation-2d.svg]]

** 2D Box Condition
To test numerical stability of our methods we introduce a box constrain condition, that traps some concentration in the center.

#+begin_src python :tangle src/diffusion.py :eval never :exports none
alpha = 0.99
gamma = 0.002
depth = 1e-3
a = 4
b = 200

exp_kernel_smooth = lambda r: 1. - 0.99 * np.exp(-(1.1**b) * a*r**a)
exp_kernel = lambda r: alpha * np.exp( - r / gamma)

def R(x,y , p=2):
    center = np.array([0.5,0.5])
    r = 0.2
    thicc = 0.005
    return np.maximum(0. , np.abs((np.abs(x -center[0])**p + np.abs(y - center[1])**p)**(1/p) - r) - thicc)

def radius(x,y , p=2):
    center = np.array([0.5,0.5])
    return np.abs((np.abs(x -center[0])**p + np.abs(y - center[1])**p)**(1/p))

def smooth_box(x,y):
    r = 0.2
    return exp_kernel_smooth(np.abs(radius(x,y, p=100) - r))



def box(x,y , p=2):
    return np.maximum(depth , 1. -  exp_kernel(R(x,y , p=100)))
def circle(x,y , p=2):
    return np.maximum(depth , 1. -  exp_kernel(R(x,y , p=2)))
def rhombus(x,y , p=2):
    return np.maximum(depth , 1. -  exp_kernel(R(x,y , p=1)))
#+end_src


*** Diffusivity
#+name: 2D Box Constraints
#+begin_src python :results graphics file output :file images/box-constraints.svg :exports results
import src.diffusion as D
reload(D)

N = 1000
M = 1000
x = np.linspace(0.,1., N)
y= np.linspace(0.,1., M)
grid = np.meshgrid(x,y)
diffusion_b = D.box(grid[0] , grid[1])
diffusion_b = diffusion_b.reshape((N,M))
diffusion_c = D.circle(grid[0] , grid[1])
diffusion_c = diffusion_c.reshape((N,M))
diffusion_r = D.rhombus(grid[0] , grid[1])
diffusion_r = diffusion_r.reshape((N,M))

fig,axis= plt.subplots(1,3 , figsize=(14,4))
im1 = axis[0].imshow(diffusion_b , cmap="magma" , extent=[0,1,0,1])
axis[0].set_title(r"Square with $L^{100}$ norm")
im2 = axis[1].imshow(diffusion_c , cmap="magma" , extent=[0,1,0,1])
axis[1].set_title(r"Circle with $L^{2}$ norm")
im2 = axis[2].imshow(diffusion_r , cmap="magma" , extent=[0,1,0,1])
axis[2].set_title(r"Rhombus with $L^{1}$ norm")

#fig.colorbar()
fig.suptitle(r"2D Box Constraints")
fig.colorbar(im1 ,ax=axis , fraction=0.025)
#+end_src

#+caption: Constraints restricting flow from the center of the Domain
#+RESULTS: 2D Box Constraints
[[file:images/box-constraints.svg]]



* Finite Volume 1D
** Program Structure
For convenience in Explanation and Execution, we bundle all required information for solving a 1D system into a python class, which is structured as follows

*** Class Structure
#+begin_src python :tangle src/fvsolver.py :noweb no-export
class FVSolver:
   N : int
   resolution : int
   h : np.float64
   x : NDArray[np.float64]
   D : Callable
   f : NDArray[np.float64]
   c : NDArray[np.float64]
   micro_basis : NDArray[np.float64]
   _T : NDArray[np.float64]

<<Init>>
<<Assemble Matrix>>
<<Boundary>>
<<Solve>>
<<Microscale Transmissions>>
<<Reconstruct Microscale Solution>>
#+end_src


*** Initialization
#+name: Init
#+begin_src python :eval never
   def __init__(self , N :int , D :Callable  , domain=(0.,1.))->None:
       self.h = (domain[1] - domain[0]) / (N-1)
       self.N = N
       self.D = D
       self.x = np.linspace(domain[0] , domain[1] , N)
       self._T =  -1/self.h * D((self.x[:-1] + self.x[1:])*0.5)
       self.f = self.h* np.ones(N)

#+end_src

*** Solving
#+name: Solve
#+begin_src python :eval never
   def solve(self):
      self.c = spsolve(self._A.tocsr() , self.f)
      return self.c

#+end_src
*** Boundary
#+name: Boundary
#+begin_src python :eval never
   def set_boundary(self , bc=(0.,0.)):
      self.f[0] = bc[0]
      self.f[-1] = bc[1]

#+end_src



*** Assembly of the linear system
*** Matrix Assembly
#+name: Assemble Matrix
#+begin_src python :eval never
   def assemble_matrix(self)-> None:
      diagp1 = np.zeros(self.N)
      diagp1[2:] =  self._T[1:]
      diagm1 = np.zeros(self.N)
      diagm1[:-2] =  self._T[:-1]
      diag0 = np.ones(self.N)
      diag0[1:-1] = -1 * (self._T[1:] + self._T[:-1])
      self._A = spdiags([diagm1 , diag0 , diagp1] , np.array( [-1, 0, 1] ))
#+end_src

*** Sparsity Pattern of the linear system
#+name: A Sparsity
#+begin_src python :session :results output graphics file :file images/A-sparsity.svg :exports results
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
reload(src.fvsolver)
f10 = FVSolver(20,  D.oscillation)
f10.assemble_matrix()
A = f10._A
sparsity = np.full(A.shape , np.nan)
Idx = A.nonzero()
sparsity[Idx] = A.todense()[Idx]
plt.imshow(sparsity , cmap="viridis")
plt.title("Sparsity Patter of A")
#+end_src

#+RESULTS: A Sparsity
[[file:images/A-sparsity.svg]]


* 1D Results
#+name: fig:comparison-1d
#+begin_src python :results graphics file output :file comparison-1d.png :exports results
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
fv = FVSolver(10 ,  D.oscillation)
fv.assemble_matrix()
fv.set_boundary()
c_course = fv.solve()

fv_ref = FVSolver(10000,  D.oscillation)
fv_ref.set_boundary()
fv_ref.assemble_matrix()
c_fine = fv_ref.solve()

fvmulti = FVSolver(10 ,  D.oscillation)
mb = fvmulti.set_multiscale_transmissions(100)
fvmulti.set_boundary()
fvmulti.assemble_matrix()
c_multi = fvmulti.solve()
fvmulti.reconstruct_multiscale()

fig , ax = plt.subplots(figsize=(10,4))
plt.plot(fv.x , c_course)
plt.plot(fvmulti.x , c_multi)
x_fine = np.linspace(0,1, len(fvmulti.micro_basis))
plt.plot(x_fine,fvmulti.reconstruction)
plt.plot(fv_ref.x,c_fine)
plt.title("Comparison Of Different Solvers\n with oscilating Diffusion" , fontsize=22)
plt.xlabel(r"$x$")
plt.ylabel(r"$c(x)$")
plt.legend(["macro" , "multiscale", "multi_fine" , "reference"] , fontsize=14)
plt.tight_layout()
#+end_src

#+RESULTS: fig:comparison-1d
[[file:comparison-1d.png]]

#+name: fig:microscale-basis
#+begin_src python :results graphics file output :file mricroscale-basis.png :exports results
import seaborn
import seaborn as sns
plt.style.use('default')
fig , ax = plt.subplots(figsize=(10,4))
for i , line in zip([3,5,9] , [":" , "-." , "--"]) :
    fv = FVSolver(i ,  D.oscillation)
    mb = fv.set_multiscale_transmissions(100)
    fineX = np.linspace(0.,1. , mb.shape[0] )
    plt.plot(fineX,mb , linestyle=line)
plt.title("Microscale Basis" , fontsize=22)
plt.xlabel(r"$x$")
plt.ylabel(r"$\phi(x)$")
plt.legend(["3 Cells" , "5 Cells", "9 Cells"], fontsize=14)
plt.tight_layout()
#+end_src

#+RESULTS: fig:microscale-basis
[[file:mricroscale-basis.png]]

* 2D results
** Oscillations
#+begin_src python :results file graphics output :file images/2d-multi-result-line.png :async t :exports results
plot_comparison(D.osc2D_line , 50 , "Line Diffusion with 4 Spikes")
#+end_src

#+RESULTS:
[[file:images/2d-multi-result-line.png]]

#+begin_src python :results file graphics output :file images/2d-multi-result-point.png :async t :exports results
plot_comparison(D.osc2D_point , 50 ,"Point Diffusion with 4 Spikes" )
#+end_src

#+RESULTS:
[[file:images/2d-multi-result-point.png]]

** Box Conditions
#+begin_src python :results file graphics output :file images/2d-multi-result-box.png :async t :exports results
plot_comparison(D.box , 50 , "Box Obstacle")
#+end_src

#+RESULTS:
[[file:images/2d-multi-result-box.png]]

#+begin_src python :results file graphics output :file images/2d-multi-result-circle.png :async t :exports results
plot_comparison(D.smooth_box , 50 , "Circle Obstacle")
#+end_src

#+RESULTS:
[[file:images/2d-multi-result-circle.png]]

#+begin_src python :results file graphics output :file images/2d-multi-result-square.png :async t :exports results
plot_comparison(D.rhombus , 50 , "Diamond Obstacle")
#+end_src

#+RESULTS:
[[file:images/2d-multi-result-square.png]]

* Error
** 1D Error

#+name: fig:error-1d
#+begin_src python :results graphics file output :file error.png :exports results
import src.diffusion as diffusionModule
import numpy as np
import matplotlib.pyplot as plt
from importlib import reload
reload(diffusionModule)
import src.fvsolver as fvModule
reload(fvModule)
diffusionFunction = lambda x: diffusionModule.oscillation(x,eps=1/20)


fineX = np.linspace(0, 1, 10000)
solver = fvModule.FVSolver(10000, diffusionFunction, (0,1))
solver.set_boundary()
solver.assemble_matrix()
referenceSolution = solver.solve()

# plt.plot(fineX , referenceSolution)

gridCoarseLevels = np.arange(1, 500, 1)
gridCoarseLevelsMulti = np.arange(2, 110, 1)

singleScaleErrorLevels = []
multiScaleErrorLevels = []
multiScaleReconstructErrorLevels = []


for coarseLevel in gridCoarseLevels:
    # solve single scale
    coarseX = np.linspace(0,1 ,coarseLevel)
    solver = fvModule.FVSolver(coarseLevel, diffusionFunction, (0,1))
    solver.set_boundary()
    solver.assemble_matrix()
    coarseSolution = solver.solve()
    interpolatedCoarseSolution = np.interp(fineX, coarseX, coarseSolution)
    error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
    singleScaleErrorLevels.append(error)

for coarseLevel in gridCoarseLevelsMulti:
    #solve multi scale
    coarseX = np.linspace(0,1 ,coarseLevel)
    solver = fvModule.FVSolver(coarseLevel, diffusionFunction, (0,1))
    solver.set_boundary()
    mb = solver.set_multiscale_transmissions(1000)
    solver.assemble_matrix()
    coarseSolution = solver.solve()
    interpolatedCoarseSolution = np.interp(fineX, coarseX, coarseSolution)
    error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
    multiScaleErrorLevels.append(error)


    reconstructedSolution = solver.reconstruct_multiscale()
    reconstructedX = np.linspace(0,1,len(solver.micro_basis))
    interpolatedCoarseSolution = np.interp(fineX, reconstructedX, solver.reconstruction)
    error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
    multiScaleReconstructErrorLevels.append(error)

plt.figure(figsize=(6,4))
plt.scatter(gridCoarseLevels, singleScaleErrorLevels, marker=".", label="single-scale")
plt.scatter(gridCoarseLevelsMulti, multiScaleErrorLevels, marker="x", alpha=0.5, label="multi-scale")
plt.scatter(gridCoarseLevelsMulti, multiScaleReconstructErrorLevels, marker="+", alpha=0.5, label="multi-scale reconstructed")

plt.title("1D MSE Single vs Multiscale\n1000 subgrid cells\n1D Diffusion 20 Spikes")

plt.xlabel("1D coarse grid resolution")
plt.ylabel("Mean Square Error")
plt.gca().set_xscale('log')
plt.gca().set_yscale('log')
plt.legend()
plt.tight_layout()

#+end_src

#+RESULTS: fig:error-1d
[[file:error.png]]

** 2D Error
#+name: plot-2d-error
#+begin_src python :exports none :results silent
import src.diffusion as diffusionModule
import numpy as np
import matplotlib.pyplot as plt
from importlib import reload
reload(diffusionModule)
import src.fvsolver as fvModule
reload(fvModule)
from importlib import reload
import numpy as np
import matplotlib.pyplot as plt
import src.fvsolver as fvModule
from scipy.interpolate import RegularGridInterpolator
reload(fvModule)

def plot_error_2d(diffusionFunction  , gridCoarseLevels , gridCoarseLevelsMulti , subtitle):
    singleScaleErrorLevels = []
    multiScaleErrorLevels = []
    multiScaleReconstructErrorLevels = []

    fineN = 1000
    fineX = np.linspace(0, 1, fineN)
    fineY = np.linspace(0, 1, fineN)
    fineXX, fineYY = np.meshgrid(fineX, fineY)
    finePoints = np.column_stack([fineXX.ravel(), fineYY.ravel()])
    solver = fvModule.FVSolver2D(fineN, fineN, diffusionFunction)
    solver.set_boundary()
    solver.assemble_matrix()
    referenceSolution = solver.solve()
    for coarseLevel in gridCoarseLevels:
        # solve single scale
        coarseX = np.linspace(0, 1, coarseLevel)
        coarseY = np.linspace(0, 1, coarseLevel)
        coarseXX, coarseYY = np.meshgrid(coarseX, coarseY)
        coarsePoints = np.column_stack([coarseXX.ravel(), coarseYY.ravel()])

        solver = fvModule.FVSolver2D(coarseLevel,coarseLevel, diffusionFunction)
        solver.set_boundary()
        solver.assemble_matrix()
        coarseSolution = solver.solve()

        interpolator = RegularGridInterpolator((coarseX , coarseY), coarseSolution)
        interpolatedCoarseSolution = interpolator(finePoints).reshape(fineXX.shape)

        error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
        singleScaleErrorLevels.append(error)

    for coarseLevel in gridCoarseLevelsMulti:
        #solve multi scale
        coarseX = np.linspace(0, 1, coarseLevel)
        coarseY = np.linspace(0, 1, coarseLevel)
        coarseXX, coarseYY = np.meshgrid(coarseX, coarseY)
        coarsePoints = np.column_stack([coarseXX.ravel(), coarseYY.ravel()])

        solver = fvModule.FVSolver2D(coarseLevel,coarseLevel, diffusionFunction)
        solver.set_boundary()
        mb = solver.set_multiscale_transmissions(100)
        solver.assemble_matrix()
        coarseSolution = solver.solve()

        interpolator = RegularGridInterpolator((coarseX , coarseY), coarseSolution)
        interpolatedCoarseSolution = interpolator(finePoints).reshape(fineXX.shape)

        error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
        multiScaleErrorLevels.append(error)


        reconstructedSolution = solver.reconstruct_multiscale()
        reconstructedX = np.linspace(0, 1, (solver.N-1) * solver.resolution)
        reconstructedY = np.linspace(0, 1, (solver.M-1) * solver.resolution)
        rcXX, rcYY = np.meshgrid(reconstructedX, reconstructedY)
        reconstructedPoints = np.column_stack([rcXX.ravel(), rcYY.ravel()])

        interpolator = RegularGridInterpolator((reconstructedX , reconstructedY), reconstructedSolution)
        interpolatedCoarseSolution = interpolator(finePoints).reshape(fineXX.shape)

        error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
        multiScaleReconstructErrorLevels.append(error)

    # print(singleScaleErrorLevels.shape)
    fig , ax = plt.subplots(figsize=(6,4))
    ax.scatter(gridCoarseLevels, singleScaleErrorLevels, marker=".", label="single-scale")
    ax.scatter(gridCoarseLevelsMulti, multiScaleErrorLevels, marker="x", alpha=0.5, label="multi-scale")
    ax.scatter(gridCoarseLevelsMulti, multiScaleReconstructErrorLevels, marker="+", alpha=0.5, label="multiscale reconstructed")

    fig.suptitle(f"2D MSE Single vs Multiscale\n{fineN} subgrid cells\n{subtitle}")

    ax.set_xlabel("2D coarse grid resolution")
    ax.set_ylabel("Mean Square Error")
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.legend()
    fig.tight_layout()
    return fig

#+end_src




#+name: fig:error-2d-circle
#+begin_src python :results graphics file output :file error-2d-circle.png :exports results :async t
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(diffusionModule.circle  , gridCoarseLevels , gridCoarseLevelsMulti , "Circle Diffusion")
#+end_src

#+RESULTS: fig:error-2d-circle
[[file:error-2d-circle.png]]


#+name: fig:error-2d-box
#+begin_src python :results graphics file output :file error-2d-box.png :exports results :async t
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(diffusionModule.box  , gridCoarseLevels , gridCoarseLevelsMulti , "Box Diffusion")
#+end_src

#+RESULTS: fig:error-2d-box
[[file:error-2d-box.png]]

#+name: fig:error-2d-diamond
#+begin_src python :results graphics file output :file error-2d-diamond.png :exports results :async t
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(diffusionModule.rhombus  , gridCoarseLevels , gridCoarseLevelsMulti , "Diamond Diffusion")
#+end_src

#+RESULTS: fig:error-2d-diamond
[[file:error-2d-diamond.png]]

#+name: fig:error-2d-line
#+begin_src python :results graphics file output :file error-2d-line.png :exports results :async t
reload(diffusionModule)
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(lambda x,y: diffusionModule.osc2D_line(x,y , eps = 1/5)  , gridCoarseLevels , gridCoarseLevelsMulti , "Line Diffusion 5 Spikes")
#+end_src

#+RESULTS: fig:error-2d-line
[[file:error-2d-line.png]]
#+name: fig:error-2d-point
#+begin_src python :results graphics file output :file error-2d-point.png :exports results :async t
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(lambda x,y:diffusionModule.osc2D_point(x,y , eps=1/5)  , gridCoarseLevels , gridCoarseLevelsMulti , "Point Diffusion 5 Spikes")

#+end_src

#+RESULTS: fig:error-2d-point
[[file:error-2d-point.png]]

* Multiscale :noexport:
In 1D
#+name: Microscale Transmissions
#+begin_src python :eval never
   def set_multiscale_transmissions(self, resolution)->NDArray[np.float64]:
      self.resolution = resolution
      micro_basis = np.zeros((self.N-1)*resolution)
      for i in range(1,self.N):
         micro_fv = FVSolver(resolution , self.D , domain=(self.x[i-1], self.x[i]))
         micro_fv.set_boundary(bc=(0.,1.))
         micro_fv.assemble_matrix()
         phi = micro_fv.solve()

         micro_basis[resolution * (i-1):resolution*i] = phi
         hm = micro_fv.h
         self._T[i-1] = -hm * np.sum(((phi[1:] - phi[:-1])/hm)**2 * self.D(micro_fv.x[:-1]))
      self.micro_basis = micro_basis
      return micro_basis

#+end_src



#+name: Reconstruct Microscale Solution
#+begin_src python :eval never

   def reconstruct_multiscale(self)->NDArray[np.float64]:
        self.reconstruction = np.zeros_like(self.micro_basis)
        for i in range(len(self.c)-1):
            n = self.resolution
            t = self.micro_basis[n*i:n*(i+1)]
            self.reconstruction[n*i:n*(i+1)] = (1-t) * self.c[i] + t * self.c[i+1]

#+end_src

#+begin_src python :results graphics file output :file images/reconstruction.png
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
fv = FVSolver(20 ,  D.oscillation)
fv.assemble_matrix()
fv.set_boundary()
c_course = fv.solve()

fv_ref = FVSolver(10000,  D.oscillation)
fv_ref.set_boundary()
fv_ref.assemble_matrix()
c_fine = fv_ref.solve()

fvmulti = FVSolver(10 ,  D.oscillation)
mb = fvmulti.set_multiscale_transmissions(100)
fvmulti.set_boundary()
fvmulti.assemble_matrix()
c_multi = fvmulti.solve()
fvmulti.reconstruct_multiscale()

plt.plot(fv.x , c_course)
plt.plot(fvmulti.x , c_multi)
x_fine = np.linspace(0,1, len(fvmulti.micro_basis))
plt.plot(x_fine,fvmulti.reconstruction)
plt.plot(fv_ref.x,c_fine)
plt.title("Comparison Of Different Solvers")
plt.xlabel(r"$x$")
plt.ylabel(r"$c(x)$")
plt.legend(["macro" , "multiscale", "multi_fine" , "reference"])
#+end_src

#+RESULTS:
[[file:images/reconstruction.png]]

#+begin_src python :results output file graphics :file images/msbasis.png
plt.plot(mb)
#+end_src

#+RESULTS:
[[file:images/msbasis.png]]

#+begin_src python :results output file graphics :file images/multi1D.png
fv.assemble_matrix()
c_multi = fv.solve()
plt.plot(c_multi)
#+end_src

#+end_src

#+begin_src python :session :file images/multiscaleplot.svg  :results output file graphics
c_macro = sp.sparse.linalg.spsolve(A_macro.tocsr(),source)
c_multi = np.zeros((N-1)* n)
x = np.linspace(0,1,N)
x_multi = np.linspace(0,1 , n*(N-1))
for i in range(len(c_macro)-1):
    t = micro_basis[n*i:n*(i+1)]
    c_multi[n*i:n*(i+1)] = (1-t) * c_macro[i] + t * c_macro[i+1]
plt.plot(x,c)
plt.plot(x,c_macro)
plt.plot(x_multi,c_multi)
plt.plot(x_fine , c_fine)
#+end_src

#+RESULTS:
[[file:images/multiscaleplot.svg]]

* Cleanup :noexport:

#+RESULTS:
: None

#+begin_src python :results output file graphics :file images/course1D.png
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
epsilon = 0.1
diff = lambda x: D.circle(x,0.5)
fv = FVSolver(100 , diff)
fv.assemble_matrix()
fv.set_boundary()
c_course = fv.solve()
wall = fv.D(fv.x)
print(np.min(wall))
#plt.plot(fv.x,wall)
plt.plot(fv.x,c_course)
#+end_src

#+RESULTS:
[[file:images/course1D.png]]

#+begin_src python :results output file graphics :file images/msbasis.png
mb = fv.set_multiscale_transmissions(100)
plt.plot(mb)
#+end_src

#+RESULTS:
[[file:images/msbasis.png]]

#+begin_src python :results output file graphics :file images/multi1D.png
fv.assemble_matrix()
c_multi = fv.solve()
plt.plot(c_multi)
#+end_src

#+RESULTS:
[[file:images/multi1D.png]]
* 2D :noexport:
#+begin_src python :tangle src/fvsolver.py :noweb no-export
import scipy as sp
import numpy as np
class FVSolver2D:
   N : int
   M : int
   h_x : np.float64
   h_y : np.float64
   x : NDArray[np.float64]
   y : NDArray[np.float64]
   D : Callable
   f : NDArray[np.float64]
   c : NDArray[np.float64]

   _T_x : NDArray[np.float64]
   _T_y : NDArray[np.float64]



<<Init 2D>>

<<Assemble 2D Matrix>>

   def set_boundary(self , bc=(0.,0. , 0. , 0.)):
      self.f[ 0,1:-1]= bc[0]
      self.f[-1,1:-1]= bc[1]
      self.f[1:-1, 0]= bc[2]
      self.f[1:-1,-1]= bc[3]


   def solve(self):
      self.c = spsolve(self._A.tocsr() , self.f.ravel()).reshape((self.N,self.M))
      return self.c

<<2D Microscale Transmissions>>
<<2D Reconstruction>>
#+end_src


#+name: Init 2D
#+begin_src python :eval never
   def __init__(self ,
                N:int,
                M:int ,
                D :Callable  ,
                domain=np.array([[0.,0.] , [1.,1.]]),
                )->None:
      self.h_x = (domain[1,0] - domain[0,0]) / (N-1)
      self.h_y = (domain[1,1] - domain[0,1]) / (M-1)
      self.x = np.linspace(domain[0,0] , domain[1,0] , N)
      self.y = np.linspace(domain[0,1] , domain[1,1] , M)
      x_h = self.x[:-1] + 0.5 * self.h_x
      y_h = self.y[:-1] + 0.5 * self.h_y
      halfgrid_x = np.meshgrid(x_h,self.y,indexing="ij")
      halfgrid_y = np.meshgrid(self.x,y_h , indexing="ij")
      self._T_x = -self.h_y/self.h_x * D(halfgrid_x[0] , halfgrid_x[1])
      self._T_y = -self.h_x/self.h_y * D(halfgrid_y[0] , halfgrid_y[1])
      self.N = N
      self.M = M
      self.D = D
      self.f = self.h_x * self.h_y* np.ones((N, M))

#+end_src


#+name: Assemble 2D Matrix
#+begin_src python :eval never
   def assemble_matrix(self)->None:
       main_diag = np.ones((  self.N,self.M))
       diag_north = np.zeros((self.N,self.M))
       diag_south = np.zeros((self.N,self.M))
       diag_east = np.zeros(( self.N,self.M))
       diag_west = np.zeros(( self.N,self.M))
       main_diag[1:-1,1:-1] =  -1* (self._T_x[:-1,1:-1] + self._T_x[1:,1:-1] + self._T_y[1:-1,:-1] + self._T_y[1:-1,1:])
       main_diag = np.ravel(main_diag)

       diag_north[1:-1,1:-1] =  self._T_y[1:-1,:-1]
       diag_south[1:-1,1:-1] =  self._T_y[1:-1,1:]
       diag_east[1:-1,1:-1] =   self._T_x[1:,1:-1]
       diag_west[1:-1,1:-1] =   self._T_x[:-1,1:-1]
       diag_north = diag_north.ravel()
       diag_south = diag_south.ravel()
       diag_west = diag_west.ravel()
       diag_east = diag_east.ravel()

       A = sp.sparse.spdiags([main_diag , diag_east , diag_west ,  diag_north , diag_south] , [0 , -self.N  , self.N , 1 , -1] , self.N*self.M , self.M*self.N)
       self._A = A.T

#+end_src

on a \(N \times M\) grid
** Numerical Flux in 2D
\begin{align*}
g_{x}(c_{i+1,j} , c_{ij}) &= - \Delta_y D(x_{i+ \frac{1}{2},j }) \frac{c_{i+1,j} - c_{ij}}{\Delta_x}\\
g_y(c_{i,j+1} , c_{ij}) &= - \Delta_x D(x_{i,j+ \frac{1}{2}}) \frac{c_{i,j+1} - c_{ij}}{\Delta_y} \\
g_x(c_{i+1j} , c_{ij}) &=   T^x_{i+1j} \left( c_{i+1j} - c_{ij}  \right)\\
g_y(c_{ij+1} , c_{ij}) &=   T^y_{ij+1} \left( c_{i+1j} - c_{ij}  \right)
\end{align*}
The boundary term can then be approximated by
\begin{align*}
 - g_{x}(c_{i,j} , c_{i-1,j}) + g_{x}(c_{i+1,j} , c_{ij})  -  g_y(c_{i,j} , c_{i,j-1}) + g_y(c_{i,j+1} , c_{ij}) &= \Delta_x \Delta_y f(x_{ij})
\end{align*}
One Dimensionalize the index
\begin{align*}
 - g_{x}(c_{i + Nj} , c_{i-1 + Nj}) + g_{x}(c_{i+1 + Nj} , c_{i + Nj})  -  g_y(c_{i + Nj} , c_{i + N(j-1)}) + g_y(c_{i + N(j+1)} , c_{i + Nj}) &= \Delta_x \Delta_y f(x_{i + Nj})
\end{align*}
plug in Flux Approach with \(\Delta_x = \Delta_y = h\)
\begin{align*}
& \left(D(x-\frac{h}{2},y)c_{i+Nj}-D(x-\frac{h}{2},y)c_{i-1+Nj}\right)\\
&-\left(D(x+\frac{h}{2},y)c_{i+1+Nj}-D(x+\frac{h}{2},y)c_{i+Nj}\right)\\
&+\left(D(x,y-\frac{h}{2})c_{i+Nj}-D(x,y-\frac{h}{2})c_{i+N(j-1)}\right)\\
&-\left(D(x,y+\frac{h}{2})c_{i+N(j+1)}-D(x,y+\frac{h}{2})c_{i+Nj}\right)
\end{align*}

\begin{align*}
& D(x-\frac{h}{2},y)c_{i+Nj}-D(x-\frac{h}{2},y)c_{i-1+Nj}  \\
&-D(x+\frac{h}{2},y)c_{i+1+Nj}+D(x+\frac{h}{2},y)c_{i+Nj}  \\
& D(x,y-\frac{h}{2})c_{i+Nj}-D(x,y-\frac{h}{2})c_{i+N(j-1)}\\
&-D(x,y+\frac{h}{2})c_{i+N(j+1)}+D(x,y+\frac{h}{2})c_{i+Nj}
\end{align*}

\begin{align*}
& -D(x-\frac{h}{2},y)c_{i-1+Nj}  \\
&-D(x+\frac{h}{2},y)c_{i+1+Nj}  \\
& -D(x,y-\frac{h}{2})c_{i+N(j-1)}\\
&-D(x,y+\frac{h}{2})c_{i+N(j+1)}\\
\left(D(x-\frac{h}{2},y) + D(x+\frac{h}{2},y) + D(x,y-\frac{h}{2}) + D(x,y+\frac{h}{2}) \right) c_{i+Nj}
\end{align*}

#+begin_src python
import os

# Set this before importing NumPy/SciPy
os.environ["OMP_NUM_THREADS"] = "16"       # For MKL/OpenMP
os.environ["OPENBLAS_NUM_THREADS"] = "16"  # For OpenBLAS
os.environ["MKL_NUM_THREADS"] = "16"       # For Intel MKL
os.environ["NUMEXPR_NUM_THREADS"] = "16"   # Just in case

import numpy as np
import scipy

#+end_src

#+RESULTS:
: None

#+begin_src python :results file graphics output :file images/2D_Diffusion.png
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
#+end_src

#+RESULTS:
[[file:images/2D_Diffusion.png]]



#+begin_src python :results file graphics output :file images/spy.svg
reload(src.fvsolver)
from src.fvsolver import FVSolver2D
smol_fv = FVSolver2D(10,10,D)
smol_fv.assemble_matrix()
plt.imshow(smol_fv._A.todense())
#plt.spy(A.T, markersize=1)
#+end_src

#+RESULTS:
[[file:images/spy.svg]]

#+begin_src python :results file graphics output :file images/_T_x.png :async t
fv2D = FVSolver2D(N,M,D)
sns.heatmap(fv2D._T_y, cmap="magma")
#+end_src

#+RESULTS:
[[file:images/_T_x.png]]

#+begin_src python :results file graphics output :file images/2d-result.png :async t :session py
import matplotlib.pyplot as plt
import numpy as np
from importlib import reload
import seaborn as sns
import src.fvsolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
from scipy.interpolate import RegularGridInterpolator
from src.fvsolver import FVSolver2D
N = 15
M = 15
res = 50
fv2D = FVSolver2D(N,M,D.rhombus)
fv2D.set_boundary()
fv2D.set_multiscale_transmissions(res)
fv2D.assemble_matrix()
c = fv2D.solve()
fv2D.reconstruct_cooked()
fig, ax = plt.subplots(figsize=(6,4))
ax.set_xticks(np.linspace(0,1.,(N+1)))
ax.set_yticks(np.linspace(0,1.,(M+1)))
ax.grid(True)
rg = np.linspace(0.,1. , N)
interp = RegularGridInterpolator((rg,rg) , c, method="cubic")
rg_interp = np.linspace(0.,1. , N * res)
grid_x,grid_y = np.meshgrid(rg_interp,rg_interp)

finePoints = np.column_stack([grid_x.ravel(), grid_y.ravel()])
c_interp = interp(finePoints).reshape((N*res , M * res))
plt.imshow(fv2D.reconstruction, cmap="magma" ,extent=[0.,1.,0.,1.])
plt.colorbar()
#plt.imshow(c_interp, cmap="magma" , extent=[0. , 1., 0., 1.])
#plt.imshow(c, cmap="magma" , extent=[0. , 1., 0., 1.])
#+end_src

#+RESULTS:
[[file:images/2d-result.png]]


#+name: fig:mircro-2d
#+begin_src python :results graphics file output :file mircro-2d.png
plt.plot(fv2D.microscale_basis_x[1,2,:])
#+end_src

#+RESULTS: fig:mircro-2d
[[file:mircro-2d.png]]

#+begin_src python :results output
error =np.linalg.norm(A@c_vec - f)
print(error)
#+end_src

#+RESULTS:
: 1.025105313314805e-12

#+begin_src python :results file graphics output :file images/2d-surf.png
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(grid[0] ,grid[1],c , cmap="magma")
#+end_src

#+RESULTS:
[[file:images/2d-surf.png]]
* 2D Multiscale :noexport:
\begin{align*}
T_{\pm } &= -\int_{Q} D(x) \phi_x'(x)^2\, \mathrm{d}x
\end{align*}
#+name:2D Microscale Transmissions
#+begin_src python :eval never
   def set_multiscale_transmissions(self, resolution):
      self.resolution = resolution
      self.microscale_basis_x = np.zeros((self._T_x.shape[0] , self._T_x.shape[1] , resolution))
      self.microscale_basis_y = np.zeros((self._T_y.shape[0] , self._T_y.shape[1] , resolution))
      for i in range(self._T_x.shape[0]):
         for j in range(self._T_x.shape[1]):
            #Do mircroscale x
            D_micro = lambda x: self.D(x, self.y[j])
            fv_micro = FVSolver(resolution , D_micro, domain=(self.x[i] , self.x[i+1]))
            fv_micro.assemble_matrix()
            fv_micro.set_boundary(bc=(0.,1.))
            phi =fv_micro.solve()
            self.microscale_basis_x[i,j,:] = phi
            self._T_x[i,j] =   -fv_micro.h * self.h_y* np.sum(((phi[1:] - phi[:-1])/(fv_micro.h))**2 * D_micro(fv_micro.x[1:] - fv_micro.h/2))

      for i in range(self._T_y.shape[0]):
         for j in range(self._T_y.shape[1]):
            # Do microscale y
            D_micro = lambda y: self.D(self.x[i], y)
            fv_micro = FVSolver(resolution , D_micro, domain=(self.y[j] , self.y[j+1]))
            fv_micro.assemble_matrix()
            fv_micro.set_boundary(bc=(0.,1.))
            phi =fv_micro.solve()
            self.microscale_basis_y[i,j,:] = phi
            self._T_y[i,j] =   -fv_micro.h * self.h_x  * np.sum(((phi[1:] - phi[:-1])/(fv_micro.h))**2 * D_micro(fv_micro.x[1:] - fv_micro.h/2))

      return self.microscale_basis_x , self.microscale_basis_y

#+end_src

#+begin_src python
import src.fvsolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
from src.fvsolver import FVSolver2D
def plot_comparison(function , resolution , typestr):
    fvref = FVSolver2D(1000, 1000,function)
    fvref.set_boundary()
    fvref.assemble_matrix()
    c_ref = fvref.solve()
    fv2D = FVSolver2D(resolution, resolution,function)
    fv2D.assemble_matrix()
    fv2D.set_boundary()
    c_course = fv2D.solve()
    mx,my = fv2D.set_multiscale_transmissions(2000)
    fv2D.assemble_matrix()
    fv2D.set_boundary()
    c = fv2D.solve()
    fig, axes = plt.subplots(1, 3, figsize=(12, 4), constrained_layout=True)  # 1 row, 2 columns
    fig.suptitle(f"{typestr} with {resolution}" + r"$\times$" + f"{resolution} Grid")
    im1 = axes[0].imshow(c_course , cmap="magma" , extent=[0,1,0,1])
    axes[0].set_title("Course")
    im2 = axes[1].imshow(c , cmap="magma" , extent=[0,1,0,1])
    axes[1].set_title("Multiscale")
    im2 = axes[2].imshow(c_ref , cmap="magma" , extent=[0,1,0,1])
    axes[2].set_title("Reference")
    plt.colorbar(im1, ax=axes)
    return fig

#+end_src

#+RESULTS:
: None

#+name: 2D Reconstruction
#+begin_src python :eval never
   def reconstruct_multiscale(self):
       self.reconstruction = np.zeros(((self.N-1) * self.resolution  , (self.M-1) * self.resolution))
       for i in range(self.N-1):
           for j in range(self.M-1):
                 x_lower = self.microscale_basis_x[i, j, :]
                 x_upper = self.microscale_basis_x[i, j+1, :]
                 y_lower = self.microscale_basis_y[i, j, :]
                 y_upper = self.microscale_basis_y[i+1, j, :]
                 interp_x = 0.5*( y_upper + y_lower)
                 interp_y = 0.5*( x_upper + x_lower)
                 #interp_x = np.linspace(0,1,self.resolution)
                 #interp_y = np.linspace(0,1,self.resolution)
                 X = np.outer(x_lower,(1-interp_x)) + np.outer(x_upper,interp_x)
                 Y = np.outer((1-interp_y) , y_lower) + np.outer(interp_y,y_upper)
                 w11 = (1 - X) * (1-Y)
                 w12 = (1-X) * Y
                 w21 = X * (1-Y)
                 w22 = X * Y
                 self.reconstruction[
                     i * self.resolution : (i + 1) * self.resolution,
                     j * self.resolution : (j + 1) * self.resolution,
                 ] = (
                     w11 * self.c[i, j]
                     + w12 * self.c[i, j + 1]
                     + w21 * self.c[i + 1, j]
                     + w22 * self.c[i + 1, j + 1]
                 )
       return self.reconstruction
   def reconstruct_cooked(self):
       """
       Taxicab interpolation
       """
       self.reconstruction = np.zeros(((self.N-1) * self.resolution  , (self.M-1) * self.resolution))
       for i in range(self.N-1):
           for j in range(self.M-1):
                 x_lower = self.microscale_basis_x[i, j, :]
                 x_upper = self.microscale_basis_x[i, j+1, :]
                 y_lower = self.microscale_basis_y[i, j, :]
                 y_upper = self.microscale_basis_y[i+1, j, :]
                 interp_x = 0.5*( y_upper + y_lower)
                 interp_y = 0.5*( x_upper + x_lower)
                 interp = np.outer(interp_x , interp_y)

                 C_lower =  np.outer(x_lower, y_lower,) > .25
                 X = np.outer(x_lower,(1-interp_x)) + np.outer(x_upper,interp_x)

                 #interp_x = np.linspace(0,1,self.resolution)
                 #interp_y = np.linspace(0,1,self.resolution)
                 self.reconstruction[
                     i * self.resolution : (i + 1) * self.resolution,
                     j * self.resolution : (j + 1) * self.resolution,
                 ] = X
       return self.reconstruction

#+end_src

#+RESULTS: 2D Reconstruction

* Reference Solution :noexport:
** Reference
Solution of the 2D Laplace equation:
\begin{align}
\label{eq:poisson}
- \Delta u(x,y) &= f(x,y) & \text{in} \quad \Omega \\
u(x,y) &= 0 & \text{on} \quad  \Gamma_D
\end{align}
where \(f(x,y) = 2 * (x+y - x^2 - y^2) \) the analytical solution is
\begin{align*}
u(x,y) &= x * (1-x) * y * (1-y)
\end{align*}

** 1D Noise

*** Code
#+begin_src python :tangle src/diffusion.py
def noise1D(x,scale=10.  , frequencies=5):
    s = lambda x ,f , a , o: a* np.sin(f*2*np.pi*(x + o))
    rng = np.random.default_rng(69)
    coeffs = rng.random((frequencies,3))
    res = np.zeros(len(x))
    for i in range(frequencies):
        res += s(x, scale *coeffs[i,0] ,coeffs[i,1] , coeffs[i,2] )
    res = res / (2*np.sum(coeffs[:,1])) + 0.5
    return res
#+end_src

*** Diffusion
#+begin_src python :exports results :results file graphics output :file images/noise.svg
import src.diffusion as D
reload(D)
x = np.linspace(0,1)
plt.plot(D.noise1D(x))
#+end_src

#+RESULTS:
[[file:images/noise.svg]]

** Noise 2D
*** Code
#+begin_src python :tangle src/diffusion.py :eval never
def noise2D(x,y , scale=8. , frequencies=20):
    s = lambda x ,f , a , o: a* np.sin(f*2*np.pi*(x + o))
    rng = np.random.default_rng(6)
    coeffs = rng.random((frequencies,6))
    res = np.zeros_like(x)
    for i in range(frequencies):
        gamma = 1.1**(i+scale)
        theta = np.pi * coeffs[i,5]
        x_prime = x * np.cos(theta) - y * np.sin(theta)
        y_prime = x * np.cos(theta) - y * np.sin(theta)
        res += 1/gamma * (s(x_prime, gamma ,coeffs[i,1] ,coeffs[i,2] ) + s(y_prime, gamma ,coeffs[i,2] , coeffs[i,4] ))

    res = res*10 + 20
    return res
    return
#+end_src

*** Difusion
#+name: 2D Noise
#+begin_src python :results file graphics output :file images/noise-2D.png :exports results
import src.diffusion as D
reload(D)
N = 100
M = 100
x = np.linspace(0.,1., N)
y= np.linspace(0.,1., M)
grid = np.meshgrid(x,y)
noise = D.noise2D(grid[0].ravel() , grid[1].ravel(), scale=10, frequencies=20)
sns.heatmap(noise.reshape(N,M))
#+end_src

#+RESULTS: 2D Noise
[[file:images/noise-2D.png]]


#+name: fig:interp-test
#+begin_src python :results graphics file output :file interp-test.png :session py
N
x = np.linspace(0,1,N)
sin = 1 / (1+ np.exp(-x))
rx = np.arange(N)
plt.plot(x,sin)
xgrid = np.add.outer(rx,rx)
xgrid[xgrid>=N] = 0
plt.imshow(x[xgrid])
#+end_src

#+RESULTS: fig:interp-test
[[file:interp-test.png]]

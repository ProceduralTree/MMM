#+title: Multiscale Finite Volume Method
#+author: Louis Gl√§nzer / Jonathan Ulmer
#+startup: latexpreview
#+startup: beamer
#+latex_compiler: lualatex
#+latex_class: beamer
#+LaTeX_CLASS_options: [presentation,small]
#+property: header-args:python :session :tangle fv.py :comments org :exports both :eval never-export
#+OPTIONS: H:2 toc:t num:t
#+BEAMER_THEME: Madrid
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+BEAMER_FRAME_OPTIONS: allowframebreaks
#+BEAMER_HEADER_EXTRA: \AtBeginSection{\frame{\sectionpage}}

#+beamer_header: \AtBeginSection[]{
#+beamer_header:   \begin{frame}
#+beamer_header:   <beamer>
#+beamer_header:  \frametitle{Outline}
#+beamer_header:  \tableofcontents[currentsection]
#+beamer_header:   \end{frame}
#+beamer_header:
#+beamer_header: }

* Preamble :noexport:
#+begin_src python :tangle src/fvsolver.py :noweb no-export :exports none
from typing import Callable
import numpy as np
from scipy.sparse import spdiags
from scipy.sparse.linalg import spsolve
from numpy.typing import NDArray
#+end_src

#+RESULTS:
: None


#+begin_src python  :exports none
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
#+end_src

#+RESULTS:
: None

#+begin_src python :tangle src/diffusion.py
import numpy as np
#+end_src


* Standard Diffusion Equation
** Numerical Problem :noexport:
#+begin_abstract
in our work, we solve the diffusion equation \eqref{eq:diffusion} with zero Dirichlet boundary and constant soure term \(f(x) = 1\). In order to investigate the effects of the multiscale method on the solution, we introduce a varied sample of diffusivity terms
\begin{align}
\label{eq:diffusion}
\nabla \cdot (D(x) \nabla c) &= f(x) & \text{in}& \, \Omega \\
c(x) &= 0 &  \text{on}& \, \partial \Omega
\end{align}
Our work provides a way to approximate a solution \(c\) to the PDE \eqref{eq:diffusion} with the Finite Volume method, and a multiscale adaptation.
#+end_abstract
** Numerical Problem
*** Diffusion Equation
- We solve the diffusion equation \eqref{eq:diffusion}
\begin{align}
\label{eq:diffusion}
\nabla \cdot (D(x) \nabla c) &= f(x) & \text{in}& \, \Omega \\
\label{eq:dirichlet}
c(x) &= 0 &  \text{on}& \, \partial \Omega
\end{align}
- with Dirichlet boundary \eqref{eq:dirichlet}
- We use constant source \(f(x) = 1 , x \in  \Omega \)
- We use a Finite Volume solver
** Derivation of the 1D Finite Volume Method :noexport:
The Finite Volume method considers the differential equation in Integral form over disjunct (\(Q_i \cap Q_j = \emptyset , i\neq  j\)) reference cells \(Q_{i}\), \(\bigcup_{i=1}^N  Q_{i} = \Omega \) and calculates the integral over them, with an integral over the reference cell boundaries using Stokes integration.


\begin{align}
\label{eq:fv-integral}
\int_{Q_i} \nabla \cdot (D(x) \nabla c )  &= \int_{Q_i} f(x) \, \mathrm{d}x  & i&=1, \dots  , N\\
\int_{\partial Q_i} D(x) \nabla c \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N
\end{align}


The Finite Volume Method then considers the solution piecewise constant on \(Q\). This creates discontinuities on the cell boundaries, where the values are not uniquely defined.
The Finite Volume method therefore introduces a numerical flux in the Ansatz and solves the integral over the flux instead.
Since the assumed solution is constant we approximate the source term \(f(\vec{x})\)  with its value on the cell center \(x_i\) of \(Q_i\) and calculate the integrals directly.

\begin{align}
\int_{\partial Q_i} g(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N\\
\label{eq:fv-discrete}
 \int_{\partial Q_i} g(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \,&=   |Q_i| f(x_i)  & i&=1, \dots  , N
\end{align}
** Derivation of the 1D Finite Volume Method
*** Discretization
- Divide \(\Omega \) into a uniform grid \(\{Q_i\}\)
  - cells \(Q_i\) are disjunct
  - \(Q_i \cap Q_j = \emptyset , i\neq  j\)
  - we assume constant solution \(c_i\) on \(Q_i\)
  - we assume constant source \(f(x) = f_i ,\, x \in Q_i\)
** Derivation of the 1D Finite Volume Method
*** Integral Form
- since the Diffusion EQ.\eqref{eq:diffusion} holds on \(\Omega \), it holds for any integral.
- \(\implies \) \eqref{eq:diffusion} holds for the integral over \(Q_i\)
\begin{equation}
\begin{aligned}
\nabla \cdot (D(x) \nabla c) &= f(x) & \text{in}& \, \Omega \\
\label{eq:cell-integral}
\int_{Q_i} \nabla \cdot (D(x) \nabla c )  &= \int_{Q_i} f(x) \, \mathrm{d}x  & i&=1, \dots  , N
\end{aligned}
\end{equation}
- We use the constant source to evaluate the right hand side
- We transform \eqref{eq:cell-integral} with the Stokes theorem
  - reduces the derivative degree on \(c\) and \(D\)
\begin{align}
\label{eq:2}
\int_{\partial Q_i} D(x) \nabla c \cdot \vec{n} \, \mathrm{d}S \, &=  |Q_i| f_i  & i&=1, \dots  , N
\end{align}
** Derivation of the 1D Finite Volume Method
*** Numerical Flux
- constant solution
- \(c\) is discontinuous on \(\partial Q\)
- \(\nabla c\) is not defined on the cell boundary
- we replace \(D(x) \nabla c\) with numerical flux \(\vec{g}\)
- \(\vec{g}\) describes flux of the solution between neighbouring cells
\begin{align}
\int_{\partial Q_i} D(x) \nabla c \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N\\
\int_{\partial Q_i} \vec{g}(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \, &=   \int_{Q_i} f(x) \, \mathrm{d} x & i&=1, \dots  , N
\end{align}
** Numerical flux approximation
*** 1D Flux
We employ the  flux approximation introduced in the MMM Lecture. Since we only investigated diffusion terms with an analytical representation, we are able to calculate this value directly.
\begin{align}
\label{eq:flux-1d}
g(c^+ , c^-) = - D(x^{\frac{1}{2} +}) \frac{c^+ - c^-}{h}
\end{align}
Furthermore, we introduce transmissitivities \(T_{\pm }\) between both cells.
\begin{align*}
g(c^+ , c^-) &= T_{\pm } * \left( c^+ - c^- \right) \\
T_{\pm } &= - D(x^{\frac{1}{2}+}) \frac{1}{h}
\end{align*}
** Numerical flux approximation
*** 2D Flux
We define the flux term \(\vec{g} := (g_x , g_y)^T\) in 2 Dimensions very similar to those in one dimension.
\begin{align}
\label{eq:flux-2d}
g_{x}(c_{i+1,j} , c_{ij}) &= - \Delta_y D(x_{i+ \frac{1}{2},j }) \frac{c_{i+1,j} - c_{ij}}{\Delta_x}\\
g_y(c_{i,j+1} , c_{ij}) &= - \Delta_x D(x_{i,j+ \frac{1}{2}}) \frac{c_{i,j+1} - c_{ij}}{\Delta_y}
\end{align}
and in the same manner we introduce 2D transmissions \(T^x_{i+1j} , T^y_{ij+1}\)
\begin{align*}
g_x(c_{i+1j} , c_{ij}) &=   T^x_{i+1j} \left( c_{i+1j} - c_{ij}  \right)\\
g_y(c_{ij+1} , c_{ij}) &=   T^y_{ij+1} \left( c_{i+1j} - c_{ij}  \right)
\end{align*}
** Linearization
*** Reference Cell :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+name: fig:reference-cell
#+attr_latex: :width 0.9\textwidth
[[file:images/reference-cell.svg]]
*** Explanation :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:
- only 4 normals in 2D (2 in 1D)
- integral simplifies
\begin{align*}
 \int_{\partial Q_i} \vec{g}(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \,&=   |Q_i| f_i\\
\sum_{ n \in \partial Q}   \vec{g}(c_{ij+\vec{n}} , c_{ij}) \cdot \vec{n}  &=   |Q_i|  f_i
\end{align*}
*** Explanation :noexport:
We implemented our finite Volume solver on a rectangular grid. therefore the normals on the boundaries are constant, and the flux integral (\ref{eq:fv-discrete}) simplifies to a sum
\begin{align*}
 \int_{\partial Q_i} \vec{g}(c^+, c^-) \cdot \vec{n} \, \mathrm{d}S \,&=   |Q_i| f(x_i)  & i&=1, \dots  , N \\
\sum_{ n \in \partial Q}   \vec{g}(c_{i+j+1} , c_{i+j}) \cdot \vec{n}  &=   |Q_i|  \overline{f}(x_{i})
\end{align*}

*** 1D Flux :noexport:
- In one dimension there are only two outward normals \(n \in \{-1,1\}\),
- we use the 1D flux \eqref{eq:flux-1d}

*** TODO 2D replace with image :noexport:

- In two dimensions there are four outward cell normals
\begin{align*}
n_{\mathrm{north}}  &=
\begin{pmatrix}
0 \\ 1
\end{pmatrix}
&
n_{\mathrm{south}}  &=
\begin{pmatrix}
0 \\ -1
\end{pmatrix}
\\
n_{\mathrm{east}}  &=
\begin{pmatrix}
1 \\ 0
\end{pmatrix}
&
n_{\mathrm{west}}  &=
\begin{pmatrix}
-1 \\ 0
\end{pmatrix}
\end{align*}
- we use the 2D flux \eqref{eq:flux-2d}

** Multiscale
*** Image :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:

#+attr_latex: :width 0.9\textwidth
[[file:images/microscale-reference.svg]]
*** Explanation :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:
- Adds  microscale simulation
  - one dimensional
  - for each normal
  - \(n\) subgrid cells
- Calculates Transmissions \(T_S\)
  - with microscale solution \(\phi_{S} \)
\begin{align*}
T_{S} &= -\int_{S_0}^{S_1} D(x) (\phi'_{S} (\vec{x}))^2\, \mathrm{d}S
\end{align*}
* Example Diffusion terms

** 1D

Since the aim of multiscale Finite Volume is to improve the results for highly fluctuating diffusivities.
*** Code
#+begin_src python :tangle src/diffusion.py :eval never
def oscillation(x, eps = 0.1):
    return 1 / (2+1.9 * np.cos(2 * np.pi* x / eps))
#+end_src

*** Diffusivity :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+name: 1D Diffusion
#+begin_src python  :session :results output file graphics  :file images/D.svg :exports results
import numpy as np
import matplotlib.pyplot as plt
import src.diffusion as D
reload(D)
fig ,ax = plt.subplots(figsize=(10,4) ,facecolor='none')
x = np.linspace(0,1 ,10)
plt.plot(x , D.oscillation(x))
x_highres = np.linspace(0,1 , 100000)
plt.plot(x_highres , D.oscillation(x_highres))
plt.legend([r"$D$ Sampled on a course grid" , r"$D$"] , loc="upper right" , fontsize=14)
plt.title("1D Diffusion Coefficient" , fontsize=16)
plt.tight_layout()
#+end_src

#+RESULTS: 1D Diffusion
[[file:images/D.svg]]





** 2D Oscillation
*** Code
#+begin_src python :tangle src/diffusion.py :eval never
def osc2D_point(x,y , eps = 0.25):
    return oscillation(x, eps=eps) * oscillation(y, eps=eps)
def osc2D_line(x,y , eps = 0.25):
    return np.maximum(oscillation(x, eps=eps) , oscillation(y, eps=eps))
#+end_src


*** Diffusion :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+name: 2D Ocillation
#+begin_src python :results graphics file output :file images/oscillation-2d.svg :exports results
import src.diffusion as D
reload(D)


N = 1000
M = 1000
x = np.linspace(0.,1., N)
y= np.linspace(0.,1., M)
grid = np.meshgrid(x,y)
diffusion_b = D.osc2D_point(grid[0] , grid[1])
diffusion_b = diffusion_b.reshape((N,M))
diffusion_c = D.osc2D_line(grid[0] , grid[1])
diffusion_c = diffusion_c.reshape((N,M))

fig,axis= plt.subplots(1,2 , figsize=(10,4) , constrained_layout=True, facecolor='none')
im1 = axis[0].imshow(diffusion_b , cmap="magma" , extent=[0,1,0,1])
axis[0].set_title(r"0D Conductance Points" , fontsize=14)
im2 = axis[1].imshow(diffusion_c , cmap="magma" , extent=[0,1,0,1])
axis[1].set_title(r"1D Conductance Lines" ,fontsize=14)

#fig.colorbar()
fig.suptitle(r"Oscillating Diffusion" , fontsize=16)
fig.colorbar(im1 ,ax=axis , fraction=0.025)
#+end_src

#+RESULTS: 2D Ocillation
[[file:images/oscillation-2d.svg]]

** 2D Box Condition
To test numerical stability of our methods, we introduce a box constraint that traps some concentration in the center.

#+begin_src python :tangle src/diffusion.py :eval never :exports none
alpha = 0.99
gamma = 0.002
depth = 1e-3
a = 4
b = 200

exp_kernel_smooth = lambda r: 1. - 0.99 * np.exp(-(1.1**b) * a*r**a)
exp_kernel = lambda r: alpha * np.exp( - r / gamma)

def R(x,y , p=2):
    center = np.array([0.5,0.5])
    r = 0.2
    thicc = 0.005
    return np.maximum(0. , np.abs((np.abs(x -center[0])**p + np.abs(y - center[1])**p)**(1/p) - r) - thicc)

def radius(x,y , p=2):
    center = np.array([0.5,0.5])
    return np.abs((np.abs(x -center[0])**p + np.abs(y - center[1])**p)**(1/p))

def smooth_box(x,y):
    r = 0.2
    return exp_kernel_smooth(np.abs(radius(x,y, p=100) - r))



def box(x,y , p=2):
    return np.maximum(depth , 1. -  exp_kernel(R(x,y , p=100)))
def circle(x,y , p=2):
    return np.maximum(depth , 1. -  exp_kernel(R(x,y , p=2)))
def rhombus(x,y , p=2):
    return np.maximum(depth , 1. -  exp_kernel(R(x,y , p=1)))
#+end_src


*** Diffusivity :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+name: 2D Box Constraints
#+begin_src python :results graphics file output :file images/box-constraints.svg :exports results
import src.diffusion as D
reload(D)

N = 1000
M = 1000
x = np.linspace(0.,1., N)
y= np.linspace(0.,1., M)
grid = np.meshgrid(x,y)
diffusion_b = D.box(grid[0] , grid[1])
diffusion_b = diffusion_b.reshape((N,M))
diffusion_c = D.circle(grid[0] , grid[1])
diffusion_c = diffusion_c.reshape((N,M))
diffusion_r = D.rhombus(grid[0] , grid[1])
diffusion_r = diffusion_r.reshape((N,M))

fig,axis= plt.subplots(1,3 , figsize=(14,5) , constrained_layout=True , facecolor='none')
im1 = axis[0].imshow(diffusion_b , cmap="magma" , extent=[0,1,0,1])
axis[0].set_title(r"Square with $L^{100}$ norm" , fontsize=16)
im2 = axis[1].imshow(diffusion_c , cmap="magma" , extent=[0,1,0,1])
axis[1].set_title(r"Circle with $L^{2}$ norm" , fontsize=16)
im2 = axis[2].imshow(diffusion_r , cmap="magma" , extent=[0,1,0,1])
axis[2].set_title(r"Rhombus with $L^{1}$ norm" , fontsize=16)

#fig.colorbar()
fig.suptitle(r"2D Box Constraints" , fontsize=22)
fig.colorbar(im1 ,ax=axis , fraction=0.025)
#+end_src

#+caption: Constraints restricting flow from the center of the Domain
#+RESULTS: 2D Box Constraints
[[file:images/box-constraints.svg]]



* Finite Volume Solver
** Program Structure
*** Class Structure
#+begin_src python :tangle src/fvsolver.py :noweb no-export
class FVSolver:
   N : int
   resolution : int
   h : np.float64
   x : NDArray[np.float64]
   D : Callable
   f : NDArray[np.float64]
   c : NDArray[np.float64]
   micro_basis : NDArray[np.float64]
   _T : NDArray[np.float64]

<<Init>>
<<Assemble Matrix>>
<<Boundary>>
<<Solve>>
<<Microscale Transmissions>>
<<Reconstruct Microscale Solution>>
#+end_src

** Program Structure
*** Initialization
#+name: Init
#+begin_src python :eval never
   def __init__(self , N :int , D :Callable  , domain=(0.,1.))->None:
       self.h = (domain[1] - domain[0]) / (N-1)
       self.N = N
       self.D = D
       self.x = np.linspace(domain[0] , domain[1] , N)
       self._T =  -1/self.h * D((self.x[:-1] + self.x[1:])*0.5)
       self.f = self.h* np.ones(N)

#+end_src

** Program Structure
*** Boundary
#+name: Boundary
#+begin_src python :eval never
   def set_boundary(self , bc=(0.,0.)):
      self.f[0] = bc[0]
      self.f[-1] = bc[1]

#+end_src


*** Solving
#+name: Solve
#+begin_src python :eval never
   def solve(self):
      self.c = spsolve(self._A.tocsr() , self.f)
      return self.c

#+end_src
** Program Structure
*** Matrix Assembly
#+name: Assemble Matrix
#+begin_src python :eval never
   def assemble_matrix(self)-> None:
      diagp1 = np.zeros(self.N)
      diagp1[2:] =  self._T[1:]
      diagm1 = np.zeros(self.N)
      diagm1[:-2] =  self._T[:-1]
      diag0 = np.ones(self.N)
      diag0[1:-1] = -1 * (self._T[1:] + self._T[:-1])
      self._A = spdiags([diagm1 , diag0 , diagp1] , np.array( [-1, 0, 1] ))
#+end_src

** Program Structure
*** Sparsity Pattern of the linear system
#+name: A Sparsity
#+begin_src python :session :results output graphics file :file images/A-sparsity.svg :exports results
import matplotlib.pyplot as plt
from importlib import reload
import src.fvsolver
import src.diffusion as D
from src.fvsolver import FVSolver , FVSolver2D
reload(src.fvsolver)
f10 = FVSolver(20,  D.oscillation)
f2D = FVSolver2D(5,5 , D.osc2D_line)
f2D.assemble_matrix()
f10.assemble_matrix()
A = f10._A
A2D = f2D._A
sparsity = np.full(A.shape , np.nan)
sparsity2D = np.full(A2D.shape , np.nan)
Idxy = A2D.nonzero()
Idx = A.nonzero()
sparsity[Idx] = A.todense()[Idx]
sparsity2D[Idxy] = A2D.todense()[Idxy]

fig,axis= plt.subplots(1,2 , figsize=(10,4) , constrained_layout=True, facecolor='none')
vmin = np.nanmin(sparsity2D)
vmax = np.nanmax(sparsity2D)
im1 = axis[0].imshow(sparsity , cmap="viridis" , extent=[0,1,0,1] , vmin=vmin , vmax=vmax)
axis[0].set_title(r"1D" , fontsize=14)
#axis[0].set_facecolor('none')
axis[0].tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
im2 = axis[1].imshow(sparsity2D , cmap="viridis" , extent=[0,1,0,1],vmin=vmin , vmax=vmax)
axis[1].set_title(r"2D" ,fontsize=14)
#axis[1].set_facecolor('none')
axis[1].tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)

fig.colorbar(im1 ,ax=axis , fraction=0.025)
fig.suptitle(r"Sparsity Pattern" , fontsize=22)
#+end_src

#+caption: Non zeros values of the system matricies for a 20 cell 1D and a \(5 \times 5\) cell 2D system.
#+RESULTS: A Sparsity
[[file:images/A-sparsity.svg]]


* Simulation Results
** 1D Oscillating Diffusion
#+name: fig:comparison-1d
#+begin_src python :results graphics file output :file comparison-1d.svg :exports results
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
fv = FVSolver(9 ,  D.oscillation)
fv.assemble_matrix()
fv.set_boundary()
c_course = fv.solve()

fv_ref = FVSolver(10000,  D.oscillation)
fv_ref.set_boundary()
fv_ref.assemble_matrix()
c_fine = fv_ref.solve()

fvmulti = FVSolver(9 ,  D.oscillation)
mb = fvmulti.set_multiscale_transmissions(100)
fvmulti.set_boundary()
fvmulti.assemble_matrix()
c_multi = fvmulti.solve()
fvmulti.reconstruct_multiscale()

fig , ax = plt.subplots(2,1,figsize=(10,8) , facecolor='none')
ax[0].plot(fv.x , c_course)
ax[0].plot(fvmulti.x , c_multi)
x_fine = np.linspace(0,1, len(fvmulti.micro_basis))
ax[0].plot(x_fine,fvmulti.reconstruction)
ax[0].plot(fv_ref.x,c_fine)
ax[0].set_title("Solution with 9 cells" , fontsize=22)
ax[0].set_xlabel(r"$x$" , fontsize=14)
ax[0].set_ylabel(r"$c(x)$" , fontsize=14)
ax[0].legend(["macro" , "multiscale", "multi_fine" , "reference"] , fontsize=14)
for i , line in zip([3,5,9] , [":" , "-." , "--"]) :
    fv = FVSolver(i ,  D.oscillation)
    mb = fv.set_multiscale_transmissions(100)
    fineX = np.linspace(0.,1. , mb.shape[0] )
    ax[1].plot(fineX,mb , linestyle=line)
ax[1].set_title("Microscale Basis" , fontsize=22)
ax[1].legend(["3 Cells" , "5 Cells", "9 Cells"], fontsize=14)
ax[1].set_xlabel(r"$x$" , fontsize=14)
ax[1].set_ylabel(r"$\phi(x)$" , fontsize=14)
plt.tight_layout()
#+end_src

#+caption: Comparison between the coarse scale and the multiscale solution against a high resolution reference
#+attr_latex: :width 0.8\linewidth
#+RESULTS: fig:comparison-1d
[[file:comparison-1d.svg]]


** Line Diffusion
#+name: fig:2d-multi-result-line
#+begin_src python :results file graphics output :file images/2d-multi-result-line.svg  :exports results
plot_comparison(D.osc2D_line , 25 , r"Line Diffusion with $4 \times 4$ Spikes")
#+end_src

#+attr_latex: :width 0.55\linewidth
#+caption: Comparison of different 2D solutions with a \(1000 \times  1000\) reference solution.
#+RESULTS: fig:2d-multi-result-line
[[file:images/2d-multi-result-line.svg]]

** Point Diffusion
#+name: fig:2d-multi-result-point
#+begin_src python :results file graphics output :file images/2d-multi-result-point.svg :exports results
plot_comparison(D.osc2D_point , 25 ,r"Point Diffusion with $4\times 4$ Spikes" )
#+end_src

#+attr_latex: :width 0.55\linewidth
#+caption: Comparison of different 2D solutions with a \(1000 \times  1000\) reference solution.
#+RESULTS: fig:2d-multi-result-point
[[file:images/2d-multi-result-point.svg]]

** 2D Box
#+name: fig:2d-multi-result-box
#+begin_src python :results file graphics output :file images/2d-multi-result-box.svg  :exports results
plot_comparison(D.box , 25 , "Box Obstacle")
#+end_src

#+attr_latex: :width 0.55\linewidth
#+caption: Comparison of different 2D solutions with a \(1000 \times  1000\) reference solution.
#+attr_latex: :width 0.85\texwidth
#+RESULTS: fig:2d-multi-result-box
[[file:images/2d-multi-result-box.svg]]
** 2D Circle
#+name: fig:2d-multi-result-circle
#+begin_src python :results file graphics output :file images/2d-multi-result-circle.svg  :exports results
plot_comparison(D.circle , 25 , "Circle Obstacle")
#+end_src

#+attr_latex: :width 0.55\linewidth
#+caption: Comparison of different 2D solutions with a \(1000 \times  1000\) reference solution.
#+attr_latex: :width 0.85\texwidth
#+RESULTS: fig:2d-multi-result-circle
[[file:images/2d-multi-result-circle.svg]]
** 2D Diamond

#+name: fig:2d-multi-result-diamond
#+begin_src python :results file graphics output :file images/2d-multi-result-square.svg  :exports results
plot_comparison(D.rhombus , 25 , "Diamond Obstacle")
#+end_src

#+attr_latex: :width 0.55\linewidth
#+caption: Comparison of different 2D solutions with a \(1000 \times  1000\) reference solution.
#+attr_latex: :width 0.85\texwidth
#+RESULTS: fig:2d-multi-result-diamond
[[file:images/2d-multi-result-square.svg]]


* Error Analysis
#+name: plot-2d-error
#+begin_src python :exports none :results silent
import src.diffusion as diffusionModule
import numpy as np
import matplotlib.pyplot as plt
from importlib import reload
reload(diffusionModule)
import src.fvsolver as fvModule
reload(fvModule)
from importlib import reload
import numpy as np
import matplotlib.pyplot as plt
import src.fvsolver as fvModule
from scipy.interpolate import RegularGridInterpolator
from matplotlib.ticker import ScalarFormatter
reload(fvModule)

def plot_error_2d(diffusionFunction  , gridCoarseLevels , gridCoarseLevelsMulti , subtitle):
    singleScaleErrorLevels = []
    multiScaleErrorLevels = []
    multiScaleReconstructErrorLevels = []

    fineN = 1000
    fineX = np.linspace(0, 1, fineN)
    fineY = np.linspace(0, 1, fineN)
    fineXX, fineYY = np.meshgrid(fineX, fineY)
    finePoints = np.column_stack([fineXX.ravel(), fineYY.ravel()])
    solver = fvModule.FVSolver2D(fineN, fineN, diffusionFunction)
    solver.set_boundary()
    solver.assemble_matrix()
    referenceSolution = solver.solve()
    for coarseLevel in gridCoarseLevels:
        # solve single scale
        coarseX = np.linspace(0, 1, coarseLevel)
        coarseY = np.linspace(0, 1, coarseLevel)
        coarseXX, coarseYY = np.meshgrid(coarseX, coarseY)
        coarsePoints = np.column_stack([coarseXX.ravel(), coarseYY.ravel()])

        solver = fvModule.FVSolver2D(coarseLevel,coarseLevel, diffusionFunction)
        solver.set_boundary()
        solver.assemble_matrix()
        coarseSolution = solver.solve()

        interpolator = RegularGridInterpolator((coarseX , coarseY), coarseSolution)
        interpolatedCoarseSolution = interpolator(finePoints).reshape(fineXX.shape)

        error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
        singleScaleErrorLevels.append(error)

    for coarseLevel in gridCoarseLevelsMulti:
        #solve multi scale
        coarseX = np.linspace(0, 1, coarseLevel)
        coarseY = np.linspace(0, 1, coarseLevel)
        coarseXX, coarseYY = np.meshgrid(coarseX, coarseY)
        coarsePoints = np.column_stack([coarseXX.ravel(), coarseYY.ravel()])

        solver = fvModule.FVSolver2D(coarseLevel,coarseLevel, diffusionFunction)
        solver.set_boundary()
        mb = solver.set_multiscale_transmissions(100)
        solver.assemble_matrix()
        coarseSolution = solver.solve()

        interpolator = RegularGridInterpolator((coarseX , coarseY), coarseSolution)
        interpolatedCoarseSolution = interpolator(finePoints).reshape(fineXX.shape)

        error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
        multiScaleErrorLevels.append(error)


        reconstructedSolution = solver.reconstruct_multiscale()
        reconstructedX = np.linspace(0, 1, (solver.N-1) * solver.resolution)
        reconstructedY = np.linspace(0, 1, (solver.M-1) * solver.resolution)
        rcXX, rcYY = np.meshgrid(reconstructedX, reconstructedY)
        reconstructedPoints = np.column_stack([rcXX.ravel(), rcYY.ravel()])

        interpolator = RegularGridInterpolator((reconstructedX , reconstructedY), reconstructedSolution)
        interpolatedCoarseSolution = interpolator(finePoints).reshape(fineXX.shape)

        error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
        multiScaleReconstructErrorLevels.append(error)

    # print(singleScaleErrorLevels.shape)
    fig , ax = plt.subplots(figsize=(8,4) , facecolor='none')
    ax.scatter(gridCoarseLevels, singleScaleErrorLevels, marker=".", label="single-scale")
    ax.scatter(gridCoarseLevelsMulti, multiScaleErrorLevels, marker="x", alpha=0.5, label="multi-scale")
    ax.scatter(gridCoarseLevelsMulti, multiScaleReconstructErrorLevels, marker="+", alpha=0.5, label="multiscale reconstructed")

    fig.suptitle(f"2D MSE Single vs Multiscale" , fontsize=18)
    ax.set_xlabel("2D coarse grid resolution" , fontsize=14)
    ax.set_ylabel("Mean Square Error" , fontsize=14)
    ax.set_xscale('log' , base=2)
    ax.set_yscale('log')
    ax.xaxis.set_major_formatter(ScalarFormatter())
    ax.legend()
    fig.tight_layout()
    return fig

#+end_src
** 1D Oscillating Diffusion
#+name: fig:error-1d
#+begin_src python :results graphics file output :file error.svg :exports results
import src.diffusion as diffusionModule
import numpy as np
import matplotlib.pyplot as plt
from importlib import reload
from matplotlib.ticker import ScalarFormatter
reload(diffusionModule)
import src.fvsolver as fvModule
reload(fvModule)
diffusionFunction = lambda x: diffusionModule.oscillation(x,eps=1/40)


fineX = np.linspace(0, 1, 10000)
solver = fvModule.FVSolver(10000, diffusionFunction, (0,1))
solver.set_boundary()
solver.assemble_matrix()
referenceSolution = solver.solve()

# plt.plot(fineX , referenceSolution)

gridCoarseLevels = np.arange(2, 500, 1)
gridCoarseLevelsMulti = np.arange(2, 110, 1)

singleScaleErrorLevels = []
multiScaleErrorLevels = []
multiScaleReconstructErrorLevels = []


for coarseLevel in gridCoarseLevels:
    # solve single scale
    coarseX = np.linspace(0,1 ,coarseLevel)
    solver = fvModule.FVSolver(coarseLevel, diffusionFunction, (0,1))
    solver.set_boundary()
    solver.assemble_matrix()
    coarseSolution = solver.solve()
    interpolatedCoarseSolution = np.interp(fineX, coarseX, coarseSolution)
    error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
    singleScaleErrorLevels.append(error)

for coarseLevel in gridCoarseLevelsMulti:
    #solve multi scale
    coarseX = np.linspace(0,1 ,coarseLevel)
    solver = fvModule.FVSolver(coarseLevel, diffusionFunction, (0,1))
    solver.set_boundary()
    mb = solver.set_multiscale_transmissions(100)
    solver.assemble_matrix()
    coarseSolution = solver.solve()
    interpolatedCoarseSolution = np.interp(fineX, coarseX, coarseSolution)
    error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
    multiScaleErrorLevels.append(error)


    reconstructedSolution = solver.reconstruct_multiscale()
    reconstructedX = np.linspace(0,1,len(solver.micro_basis))
    interpolatedCoarseSolution = np.interp(fineX, reconstructedX, solver.reconstruction)
    error = np.sqrt(np.mean(np.square(referenceSolution - interpolatedCoarseSolution)))
    multiScaleReconstructErrorLevels.append(error)

plt.figure(figsize=(8,4) , facecolor='none')
plt.scatter(gridCoarseLevels, singleScaleErrorLevels, marker=".", label="single-scale")
plt.scatter(gridCoarseLevelsMulti, multiScaleErrorLevels, marker="x", alpha=0.5, label="multi-scale")
plt.scatter(gridCoarseLevelsMulti, multiScaleReconstructErrorLevels, marker="+", alpha=0.5, label="multi-scale reconstructed")

plt.title("1D MSE Single vs Multiscale" , fontsize=18)

plt.xlabel("1D coarse grid resolution" , fontsize=14)
plt.ylabel("Mean Square Error" , fontsize=14)
plt.gca().set_xscale('log', base=2)
plt.gca().set_yscale('log')
plt.gca().xaxis.set_major_formatter(ScalarFormatter())
#plt.gca().xaxis.set_ticklabels([str(t) for t in xticks])
legend =plt.legend()
plt.tight_layout()

#+end_src

#+caption: Mean Square Error (MSE) against a reference solution with a 1000 cell reference grid. For a 1D diffusion with 20 spikes and a 1000 cell microscale resolution.
#+attr_latex: :width 0.9\linewidth
#+RESULTS: fig:error-1d
[[file:error.svg]]



** 2D Circle
#+name: fig:error-2d-circle
#+begin_src python :results graphics file output :file error-2d-circle.svg :exports results
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(diffusionModule.circle  , gridCoarseLevels , gridCoarseLevelsMulti , "Circle Diffusion")
#+end_src

#+caption: Mean Square Error (MSE) against a reference solution with a \(1000\times 1000\) cell reference grid. For a circular Obstacle and a 100 cell microscale resolution.
#+attr_latex: :width 0.9\linewidth
#+RESULTS: fig:error-2d-circle
[[file:error-2d-circle.svg]]

** 2D Box
#+name: fig:error-2d-box
#+begin_src python :results graphics file output :file error-2d-box.svg :exports results
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(diffusionModule.box  , gridCoarseLevels , gridCoarseLevelsMulti , "Box Diffusion")
#+end_src

#+attr_latex: :width 0.9\linewidth
#+caption: Mean Square Error (MSE) against a reference solution with a \(1000\times 1000\) cell reference grid. For a box Obstacle and a 100 cell microscale resolution.
#+RESULTS: fig:error-2d-box
[[file:error-2d-box.svg]]

** 2D Diamond
#+name: fig:error-2d-diamond
#+begin_src python :results graphics file output :file error-2d-diamond.svg :exports results
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(diffusionModule.rhombus  , gridCoarseLevels , gridCoarseLevelsMulti , "Diamond Diffusion")
#+end_src

#+attr_latex: :width 0.9\linewidth
#+caption: Mean Square Error (MSE) against a reference solution with a \(1000\times 1000\) cell reference grid. For a diamond obstacle and a 100 cell microscale resolution.
#+RESULTS: fig:error-2d-diamond
[[file:error-2d-diamond.svg]]

** Line Diffusion
#+name: fig:error-2d-line
#+begin_src python :results graphics file output :file error-2d-line.svg :exports results
reload(diffusionModule)
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(lambda x,y: diffusionModule.osc2D_line(x,y , eps = 1/4)  , gridCoarseLevels , gridCoarseLevelsMulti , "Line Diffusion 5 Spikes")
#+end_src

#+attr_latex: :width 0.9\linewidth
#+caption: Mean Square Error (MSE) against a reference solution with a \(1000\times 1000\) cell reference grid. For a line diffusion with \(4 \time 4\) spikes and a 100 cell microscale resolution.
#+RESULTS: fig:error-2d-line
[[file:error-2d-line.svg]]
** Point Diffusion
#+name: fig:error-2d-point
#+begin_src python :results graphics file output :file error-2d-point.svg :exports results
gridCoarseLevels = np.arange(5, 200, 2)
gridCoarseLevelsMulti = np.arange(5, 100, 2)
fig = plot_error_2d(lambda x,y:diffusionModule.osc2D_point(x,y , eps=1/5)  , gridCoarseLevels , gridCoarseLevelsMulti , "Point Diffusion 5 Spikes")
#+end_src

#+attr_latex: :width 0.9\linewidth
#+caption: Mean Square Error (MSE) against a reference solution with a \(1000\times 1000\) cell reference grid. For a point diffusion with \(4 \time 4\) spikes and a 100 cell microscale resolution.
#+RESULTS: fig:error-2d-point
[[file:error-2d-point.svg]]
* Conclusion
** Conclusion
- works well for 1D
  - no performance benefit
  - expensive microscale simulations
  - worse if single scale can resolve the details
  - reconstruction works very well
- works well for some 2D cases
  - can resolve thin walls
  - can reconstruct only orthogonal detail
- no benefit in other cases
  - no benefit for point and line diffusion
- requires some differentiability conditions on \(D(\vec{x})\)
** Further Considerations
- multipoint flux approximation
- higher order 2D reconstruction
- realistic diffusion with interpolated high res data
- 3D
- irregular grid
- parallelization to make use of independent microscale simulations





















































* Multiscale :noexport:
In 1D
#+name: Microscale Transmissions
#+begin_src python :eval never
   def set_multiscale_transmissions(self, resolution)->NDArray[np.float64]:
      self.resolution = resolution
      micro_basis = np.zeros((self.N-1)*resolution)
      for i in range(1,self.N):
         micro_fv = FVSolver(resolution , self.D , domain=(self.x[i-1], self.x[i]))
         micro_fv.set_boundary(bc=(0.,1.))
         micro_fv.assemble_matrix()
         phi = micro_fv.solve()

         micro_basis[resolution * (i-1):resolution*i] = phi
         hm = micro_fv.h
         self._T[i-1] = -hm * np.sum(((phi[1:] - phi[:-1])/hm)**2 * self.D(micro_fv.x[:-1]))
      self.micro_basis = micro_basis
      return micro_basis

#+end_src



#+name: Reconstruct Microscale Solution
#+begin_src python :eval never

   def reconstruct_multiscale(self)->NDArray[np.float64]:
        self.reconstruction = np.zeros_like(self.micro_basis)
        for i in range(len(self.c)-1):
            n = self.resolution
            t = self.micro_basis[n*i:n*(i+1)]
            self.reconstruction[n*i:n*(i+1)] = (1-t) * self.c[i] + t * self.c[i+1]

#+end_src

#+begin_src python :results graphics file output :file images/reconstruction.png
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
fv = FVSolver(20 ,  D.oscillation)
fv.assemble_matrix()
fv.set_boundary()
c_course = fv.solve()

fv_ref = FVSolver(10000,  D.oscillation)
fv_ref.set_boundary()
fv_ref.assemble_matrix()
c_fine = fv_ref.solve()

fvmulti = FVSolver(10 ,  D.oscillation)
mb = fvmulti.set_multiscale_transmissions(100)
fvmulti.set_boundary()
fvmulti.assemble_matrix()
c_multi = fvmulti.solve()
fvmulti.reconstruct_multiscale()

plt.plot(fv.x , c_course)
plt.plot(fvmulti.x , c_multi)
x_fine = np.linspace(0,1, len(fvmulti.micro_basis))
plt.plot(x_fine,fvmulti.reconstruction)
plt.plot(fv_ref.x,c_fine)
plt.title("Comparison Of Different Solvers")
plt.xlabel(r"$x$")
plt.ylabel(r"$c(x)$")
plt.legend(["macro" , "multiscale", "multi_fine" , "reference"])
#+end_src

#+RESULTS:
[[file:images/reconstruction.png]]

#+begin_src python :results output file graphics :file images/msbasis.png
plt.plot(mb)
#+end_src

#+RESULTS:
[[file:images/msbasis.png]]

#+begin_src python :results output file graphics :file images/multi1D.png
fv.assemble_matrix()
c_multi = fv.solve()
plt.plot(c_multi)
#+end_src

#+end_src

#+begin_src python :session :file images/multiscaleplot.svg  :results output file graphics
c_macro = sp.sparse.linalg.spsolve(A_macro.tocsr(),source)
c_multi = np.zeros((N-1)* n)
x = np.linspace(0,1,N)
x_multi = np.linspace(0,1 , n*(N-1))
for i in range(len(c_macro)-1):
    t = micro_basis[n*i:n*(i+1)]
    c_multi[n*i:n*(i+1)] = (1-t) * c_macro[i] + t * c_macro[i+1]
plt.plot(x,c)
plt.plot(x,c_macro)
plt.plot(x_multi,c_multi)
plt.plot(x_fine , c_fine)
#+end_src

#+RESULTS:
[[file:images/multiscaleplot.svg]]

* Cleanup :noexport:

#+RESULTS:
: None

#+begin_src python :results output file graphics :file images/course1D.png
from importlib import reload
import src.fvsolver
from src.fvsolver import FVSolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
epsilon = 0.1
diff = lambda x: D.circle(x,0.5)
fv = FVSolver(100 , diff)
fv.assemble_matrix()
fv.set_boundary()
c_course = fv.solve()
wall = fv.D(fv.x)
print(np.min(wall))
#plt.plot(fv.x,wall)
plt.plot(fv.x,c_course)
#+end_src

#+RESULTS:
[[file:images/course1D.png]]

#+begin_src python :results output file graphics :file images/msbasis.png
mb = fv.set_multiscale_transmissions(100)
plt.plot(mb)
#+end_src

#+RESULTS:
[[file:images/msbasis.png]]

#+begin_src python :results output file graphics :file images/multi1D.png
fv.assemble_matrix()
c_multi = fv.solve()
plt.plot(c_multi)
#+end_src

#+RESULTS:
[[file:images/multi1D.png]]
* 2D :noexport:
#+begin_src python :tangle src/fvsolver.py :noweb no-export
import scipy as sp
import numpy as np
class FVSolver2D:
   N : int
   M : int
   h_x : np.float64
   h_y : np.float64
   x : NDArray[np.float64]
   y : NDArray[np.float64]
   D : Callable
   f : NDArray[np.float64]
   c : NDArray[np.float64]

   _T_x : NDArray[np.float64]
   _T_y : NDArray[np.float64]



<<Init 2D>>

<<Assemble 2D Matrix>>

   def set_boundary(self , bc=(0.,0. , 0. , 0.)):
      self.f[ 0,1:-1]= bc[0]
      self.f[-1,1:-1]= bc[1]
      self.f[1:-1, 0]= bc[2]
      self.f[1:-1,-1]= bc[3]


   def solve(self):
      self.c = spsolve(self._A.tocsr() , self.f.ravel()).reshape((self.N,self.M))
      return self.c

<<2D Microscale Transmissions>>
<<2D Reconstruction>>
#+end_src


#+name: Init 2D
#+begin_src python :eval never
   def __init__(self ,
                N:int,
                M:int ,
                D :Callable  ,
                domain=np.array([[0.,0.] , [1.,1.]]),
                )->None:
      self.h_x = (domain[1,0] - domain[0,0]) / (N-1)
      self.h_y = (domain[1,1] - domain[0,1]) / (M-1)
      self.x = np.linspace(domain[0,0] , domain[1,0] , N)
      self.y = np.linspace(domain[0,1] , domain[1,1] , M)
      x_h = self.x[:-1] + 0.5 * self.h_x
      y_h = self.y[:-1] + 0.5 * self.h_y
      halfgrid_x = np.meshgrid(x_h,self.y,indexing="ij")
      halfgrid_y = np.meshgrid(self.x,y_h , indexing="ij")
      self._T_x = -self.h_y/self.h_x * D(halfgrid_x[0] , halfgrid_x[1])
      self._T_y = -self.h_x/self.h_y * D(halfgrid_y[0] , halfgrid_y[1])
      self.N = N
      self.M = M
      self.D = D
      self.f = self.h_x * self.h_y* np.ones((N, M))

#+end_src


#+name: Assemble 2D Matrix
#+begin_src python :eval never
   def assemble_matrix(self)->None:
       main_diag = np.ones((  self.N,self.M))
       diag_north = np.zeros((self.N,self.M))
       diag_south = np.zeros((self.N,self.M))
       diag_east = np.zeros(( self.N,self.M))
       diag_west = np.zeros(( self.N,self.M))
       main_diag[1:-1,1:-1] =  -1* (self._T_x[:-1,1:-1] + self._T_x[1:,1:-1] + self._T_y[1:-1,:-1] + self._T_y[1:-1,1:])
       main_diag = np.ravel(main_diag)

       diag_north[1:-1,1:-1] =  self._T_y[1:-1,:-1]
       diag_south[1:-1,1:-1] =  self._T_y[1:-1,1:]
       diag_east[1:-1,1:-1] =   self._T_x[1:,1:-1]
       diag_west[1:-1,1:-1] =   self._T_x[:-1,1:-1]
       diag_north = diag_north.ravel()
       diag_south = diag_south.ravel()
       diag_west = diag_west.ravel()
       diag_east = diag_east.ravel()

       A = sp.sparse.spdiags([main_diag , diag_east , diag_west ,  diag_north , diag_south] , [0 , -self.N  , self.N , 1 , -1] , self.N*self.M , self.M*self.N)
       self._A = A.T

#+end_src

on a \(N \times M\) grid
** Numerical Flux in 2D
\begin{align*}
g_{x}(c_{i+1,j} , c_{ij}) &= - \Delta_y D(x_{i+ \frac{1}{2},j }) \frac{c_{i+1,j} - c_{ij}}{\Delta_x}\\
g_y(c_{i,j+1} , c_{ij}) &= - \Delta_x D(x_{i,j+ \frac{1}{2}}) \frac{c_{i,j+1} - c_{ij}}{\Delta_y} \\
g_x(c_{i+1j} , c_{ij}) &=   T^x_{i+1j} \left( c_{i+1j} - c_{ij}  \right)\\
g_y(c_{ij+1} , c_{ij}) &=   T^y_{ij+1} \left( c_{i+1j} - c_{ij}  \right)
\end{align*}
The boundary term can then be approximated by
\begin{align*}
 - g_{x}(c_{i,j} , c_{i-1,j}) + g_{x}(c_{i+1,j} , c_{ij})  -  g_y(c_{i,j} , c_{i,j-1}) + g_y(c_{i,j+1} , c_{ij}) &= \Delta_x \Delta_y f(x_{ij})
\end{align*}
One Dimensionalize the index
\begin{align*}
 - g_{x}(c_{i + Nj} , c_{i-1 + Nj}) + g_{x}(c_{i+1 + Nj} , c_{i + Nj})  -  g_y(c_{i + Nj} , c_{i + N(j-1)}) + g_y(c_{i + N(j+1)} , c_{i + Nj}) &= \Delta_x \Delta_y f(x_{i + Nj})
\end{align*}
plug in Flux Approach with \(\Delta_x = \Delta_y = h\)
\begin{align*}
& \left(D(x-\frac{h}{2},y)c_{i+Nj}-D(x-\frac{h}{2},y)c_{i-1+Nj}\right)\\
&-\left(D(x+\frac{h}{2},y)c_{i+1+Nj}-D(x+\frac{h}{2},y)c_{i+Nj}\right)\\
&+\left(D(x,y-\frac{h}{2})c_{i+Nj}-D(x,y-\frac{h}{2})c_{i+N(j-1)}\right)\\
&-\left(D(x,y+\frac{h}{2})c_{i+N(j+1)}-D(x,y+\frac{h}{2})c_{i+Nj}\right)
\end{align*}

\begin{align*}
& D(x-\frac{h}{2},y)c_{i+Nj}-D(x-\frac{h}{2},y)c_{i-1+Nj}  \\
&-D(x+\frac{h}{2},y)c_{i+1+Nj}+D(x+\frac{h}{2},y)c_{i+Nj}  \\
& D(x,y-\frac{h}{2})c_{i+Nj}-D(x,y-\frac{h}{2})c_{i+N(j-1)}\\
&-D(x,y+\frac{h}{2})c_{i+N(j+1)}+D(x,y+\frac{h}{2})c_{i+Nj}
\end{align*}

\begin{align*}
& -D(x-\frac{h}{2},y)c_{i-1+Nj}  \\
&-D(x+\frac{h}{2},y)c_{i+1+Nj}  \\
& -D(x,y-\frac{h}{2})c_{i+N(j-1)}\\
&-D(x,y+\frac{h}{2})c_{i+N(j+1)}\\
\left(D(x-\frac{h}{2},y) + D(x+\frac{h}{2},y) + D(x,y-\frac{h}{2}) + D(x,y+\frac{h}{2}) \right) c_{i+Nj}
\end{align*}

#+begin_src python
import os

# Set this before importing NumPy/SciPy
os.environ["OMP_NUM_THREADS"] = "16"       # For MKL/OpenMP
os.environ["OPENBLAS_NUM_THREADS"] = "16"  # For OpenBLAS
os.environ["MKL_NUM_THREADS"] = "16"       # For Intel MKL
os.environ["NUMEXPR_NUM_THREADS"] = "16"   # Just in case

import numpy as np
import scipy

#+end_src

#+RESULTS:
: None

#+begin_src python :results file graphics output :file images/2D_Diffusion.png
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
#+end_src

#+RESULTS:
[[file:images/2D_Diffusion.png]]



#+begin_src python :results file graphics output :file images/spy.svg
reload(src.fvsolver)
from src.fvsolver import FVSolver2D
smol_fv = FVSolver2D(10,10,D)
smol_fv.assemble_matrix()
plt.imshow(smol_fv._A.todense())
#plt.spy(A.T, markersize=1)
#+end_src

#+RESULTS:
[[file:images/spy.svg]]

#+begin_src python :results file graphics output :file images/_T_x.png :async t
fv2D = FVSolver2D(N,M,D)
sns.heatmap(fv2D._T_y, cmap="magma")
#+end_src

#+RESULTS:
[[file:images/_T_x.png]]

#+begin_src python :results file graphics output :file images/2d-result.png :async t :session py
import matplotlib.pyplot as plt
import numpy as np
from importlib import reload
import seaborn as sns
import src.fvsolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
from scipy.interpolate import RegularGridInterpolator
from src.fvsolver import FVSolver2D
N = 15
M = 15
res = 50
fv2D = FVSolver2D(N,M,D.rhombus)
fv2D.set_boundary()
fv2D.set_multiscale_transmissions(res)
fv2D.assemble_matrix()
c = fv2D.solve()
fv2D.reconstruct_cooked()
fig, ax = plt.subplots(figsize=(6,4))
ax.set_xticks(np.linspace(0,1.,(N+1)))
ax.set_yticks(np.linspace(0,1.,(M+1)))
ax.grid(True)
rg = np.linspace(0.,1. , N)
interp = RegularGridInterpolator((rg,rg) , c, method="cubic")
rg_interp = np.linspace(0.,1. , N * res)
grid_x,grid_y = np.meshgrid(rg_interp,rg_interp)

finePoints = np.column_stack([grid_x.ravel(), grid_y.ravel()])
c_interp = interp(finePoints).reshape((N*res , M * res))
plt.imshow(fv2D.reconstruction, cmap="magma" ,extent=[0.,1.,0.,1.])
plt.colorbar()
#plt.imshow(c_interp, cmap="magma" , extent=[0. , 1., 0., 1.])
#plt.imshow(c, cmap="magma" , extent=[0. , 1., 0., 1.])
#+end_src

#+RESULTS:
[[file:images/2d-result.png]]


#+name: fig:mircro-2d
#+begin_src python :results graphics file output :file mircro-2d.png
plt.plot(fv2D.microscale_basis_x[1,2,:])
#+end_src

#+RESULTS: fig:mircro-2d
[[file:mircro-2d.png]]

#+begin_src python :results output
error =np.linalg.norm(A@c_vec - f)
print(error)
#+end_src

#+RESULTS:
: 1.025105313314805e-12

#+begin_src python :results file graphics output :file images/2d-surf.png
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(grid[0] ,grid[1],c , cmap="magma")
#+end_src

#+RESULTS:
[[file:images/2d-surf.png]]
* 2D Multiscale :noexport:
\begin{align*}
T_{\pm } &= -\int_{Q} D(x) \phi_x'(x)^2\, \mathrm{d}x
\end{align*}
#+name:2D Microscale Transmissions
#+begin_src python :eval never
   def set_multiscale_transmissions(self, resolution):
      self.resolution = resolution
      self.microscale_basis_x = np.zeros((self._T_x.shape[0] , self._T_x.shape[1] , resolution))
      self.microscale_basis_y = np.zeros((self._T_y.shape[0] , self._T_y.shape[1] , resolution))
      for i in range(self._T_x.shape[0]):
         for j in range(self._T_x.shape[1]):
            #Do mircroscale x
            D_micro = lambda x: self.D(x, self.y[j])
            fv_micro = FVSolver(resolution , D_micro, domain=(self.x[i] , self.x[i+1]))
            fv_micro.assemble_matrix()
            fv_micro.set_boundary(bc=(0.,1.))
            phi =fv_micro.solve()
            self.microscale_basis_x[i,j,:] = phi
            self._T_x[i,j] =   -fv_micro.h * self.h_y* np.sum(((phi[1:] - phi[:-1])/(fv_micro.h))**2 * D_micro(fv_micro.x[1:] - fv_micro.h/2))

      for i in range(self._T_y.shape[0]):
         for j in range(self._T_y.shape[1]):
            # Do microscale y
            D_micro = lambda y: self.D(self.x[i], y)
            fv_micro = FVSolver(resolution , D_micro, domain=(self.y[j] , self.y[j+1]))
            fv_micro.assemble_matrix()
            fv_micro.set_boundary(bc=(0.,1.))
            phi =fv_micro.solve()
            self.microscale_basis_y[i,j,:] = phi
            self._T_y[i,j] =   -fv_micro.h * self.h_x  * np.sum(((phi[1:] - phi[:-1])/(fv_micro.h))**2 * D_micro(fv_micro.x[1:] - fv_micro.h/2))

      return self.microscale_basis_x , self.microscale_basis_y

#+end_src

#+begin_src python
from importlib import reload
import src.fvsolver
import src.diffusion as D
reload(src.fvsolver)
reload(D)
from src.fvsolver import FVSolver2D
def plot_comparison(function , resolution , typestr):
    fvref = FVSolver2D(1000, 1000,function)
    fvref.set_boundary()
    fvref.assemble_matrix()
    c_ref = fvref.solve()
    fv2D = FVSolver2D(resolution, resolution,function)
    fv2D.assemble_matrix()
    fv2D.set_boundary()
    c_course = fv2D.solve()
    mx,my = fv2D.set_multiscale_transmissions(200)
    fv2D.assemble_matrix()
    fv2D.set_boundary()
    c = fv2D.solve()
    reconstructed = fv2D.reconstruct_multiscale()
    vmin = np.min([np.min(c_course) , np.min(c_ref) , np.min(c) , np.min(reconstructed)])
    vmax = np.max([np.max(c_course) , np.max(c_ref) , np.max(c) , np.max(reconstructed)])
    fig, axes = plt.subplots(2, 2, figsize=(9, 8), constrained_layout=True , facecolor='none' )
    fig.suptitle(f"{typestr} on a {resolution}" + r"$\times$" + f"{resolution} Grid" , fontsize=22)
    im1 = axes[0,0].imshow(c_course , cmap="magma" , extent=[0,1,0,1] , vmin=vmin , vmax=vmax)
    axes[0,0].set_title("Course" , fontsize=16)
    im2 = axes[1,0].imshow(c , cmap="magma" , extent=[0,1,0,1], vmin=vmin , vmax=vmax)
    axes[1,0].set_title("Multiscale" ,fontsize=16)
    im2 = axes[1,1].imshow(reconstructed , cmap="magma" , extent=[0,1,0,1], vmin=vmin , vmax=vmax)
    axes[1,1].set_title("Multiscale Reconstruction" , fontsize=16)
    im2 = axes[0,1].imshow(c_ref , cmap="magma" , extent=[0,1,0,1], vmin=vmin , vmax=vmax)
    axes[0,1].set_title("Reference" , fontsize=16)
    plt.colorbar(im1, ax=axes)
    return fig

#+end_src

#+RESULTS:
: None

#+name: 2D Reconstruction
#+begin_src python :eval never
   def reconstruct_multiscale(self):
       self.reconstruction = np.zeros(((self.N-1) * self.resolution  , (self.M-1) * self.resolution))
       for i in range(self.N-1):
           for j in range(self.M-1):
                 x_lower = self.microscale_basis_x[i, j, :]
                 x_upper = self.microscale_basis_x[i, j+1, :]
                 y_lower = self.microscale_basis_y[i, j, :]
                 y_upper = self.microscale_basis_y[i+1, j, :]
                 interp_x = 0.5*( y_upper + y_lower)
                 interp_y = 0.5*( x_upper + x_lower)
                 #interp_x = np.linspace(0,1,self.resolution)
                 #interp_y = np.linspace(0,1,self.resolution)
                 X = np.outer(x_lower,(1-interp_x)) + np.outer(x_upper,interp_x)
                 Y = np.outer((1-interp_y) , y_lower) + np.outer(interp_y,y_upper)
                 w11 = (1 - X) * (1-Y)
                 w12 = (1-X) * Y
                 w21 = X * (1-Y)
                 w22 = X * Y
                 self.reconstruction[
                     i * self.resolution : (i + 1) * self.resolution,
                     j * self.resolution : (j + 1) * self.resolution,
                 ] = (
                     w11 * self.c[i, j]
                     + w12 * self.c[i, j + 1]
                     + w21 * self.c[i + 1, j]
                     + w22 * self.c[i + 1, j + 1]
                 )
       return self.reconstruction
   def reconstruct_cooked(self):
       """
       Taxicab interpolation
       """
       self.reconstruction = np.zeros(((self.N-1) * self.resolution  , (self.M-1) * self.resolution))
       for i in range(self.N-1):
           for j in range(self.M-1):
                 x_lower = self.microscale_basis_x[i, j, :]
                 x_upper = self.microscale_basis_x[i, j+1, :]
                 y_lower = self.microscale_basis_y[i, j, :]
                 y_upper = self.microscale_basis_y[i+1, j, :]
                 interp_x = 0.5*( y_upper + y_lower)
                 interp_y = 0.5*( x_upper + x_lower)
                 interp = np.outer(interp_x , interp_y)

                 C_lower =  np.outer(x_lower, y_lower,) > .25
                 X = np.outer(x_lower,(1-interp_x)) + np.outer(x_upper,interp_x)

                 #interp_x = np.linspace(0,1,self.resolution)
                 #interp_y = np.linspace(0,1,self.resolution)
                 self.reconstruction[
                     i * self.resolution : (i + 1) * self.resolution,
                     j * self.resolution : (j + 1) * self.resolution,
                 ] = X
       return self.reconstruction

#+end_src

#+RESULTS: 2D Reconstruction

* Reference Solution :noexport:
** Reference
Solution of the 2D Laplace equation:
\begin{align}
\label{eq:poisson}
- \Delta u(x,y) &= f(x,y) & \text{in} \quad \Omega \\
u(x,y) &= 0 & \text{on} \quad  \Gamma_D
\end{align}
where \(f(x,y) = 2 * (x+y - x^2 - y^2) \) the analytical solution is
\begin{align*}
u(x,y) &= x * (1-x) * y * (1-y)
\end{align*}

** 1D Noise

*** Code
#+begin_src python :tangle src/diffusion.py
def noise1D(x,scale=10.  , frequencies=5):
    s = lambda x ,f , a , o: a* np.sin(f*2*np.pi*(x + o))
    rng = np.random.default_rng(69)
    coeffs = rng.random((frequencies,3))
    res = np.zeros(len(x))
    for i in range(frequencies):
        res += s(x, scale *coeffs[i,0] ,coeffs[i,1] , coeffs[i,2] )
    res = res / (2*np.sum(coeffs[:,1])) + 0.5
    return res
#+end_src

*** Diffusion
#+begin_src python :exports results :results file graphics output :file images/noise.svg
import src.diffusion as D
reload(D)
x = np.linspace(0,1)
plt.plot(D.noise1D(x))
#+end_src

#+RESULTS:
[[file:images/noise.svg]]

** Noise 2D
*** Code
#+begin_src python :tangle src/diffusion.py :eval never
def noise2D(x,y , scale=8. , frequencies=20):
    s = lambda x ,f , a , o: a* np.sin(f*2*np.pi*(x + o))
    rng = np.random.default_rng(6)
    coeffs = rng.random((frequencies,6))
    res = np.zeros_like(x)
    for i in range(frequencies):
        gamma = 1.1**(i+scale)
        theta = np.pi * coeffs[i,5]
        x_prime = x * np.cos(theta) - y * np.sin(theta)
        y_prime = x * np.cos(theta) - y * np.sin(theta)
        res += 1/gamma * (s(x_prime, gamma ,coeffs[i,1] ,coeffs[i,2] ) + s(y_prime, gamma ,coeffs[i,2] , coeffs[i,4] ))

    res = res*10 + 20
    return res
    return
#+end_src

*** Difusion
#+name: 2D Noise
#+begin_src python :results file graphics output :file images/noise-2D.png :exports results
import src.diffusion as D
reload(D)
N = 100
M = 100
x = np.linspace(0.,1., N)
y= np.linspace(0.,1., M)
grid = np.meshgrid(x,y)
noise = D.noise2D(grid[0].ravel() , grid[1].ravel(), scale=10, frequencies=20)
sns.heatmap(noise.reshape(N,M))
#+end_src

#+RESULTS: 2D Noise
[[file:images/noise-2D.png]]


#+name: fig:interp-test
#+begin_src python :results graphics file output :file interp-test.png :session py
N
x = np.linspace(0,1,N)
sin = 1 / (1+ np.exp(-x))
rx = np.arange(N)
plt.plot(x,sin)
xgrid = np.add.outer(rx,rx)
xgrid[xgrid>=N] = 0
plt.imshow(x[xgrid])
#+end_src

#+RESULTS: fig:interp-test
[[file:interp-test.png]]
